@page "/doc"
@page "/doc/{documentId}"
@rendermode Microsoft.AspNetCore.Components.Web.RenderMode.InteractiveServer
@using System
@using System.Collections.Generic
@using System.Globalization
@using System.Linq
@using System.Net
@using System.Net.Http
@using System.Net.Http.Json
@using System.Security
@using System.Security.Claims
@using System.Text.RegularExpressions
@using System.Threading
@using BlazorApp.Components.Editor
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.EntityFrameworkCore
@using Microsoft.Extensions.Logging
@using Microsoft.Extensions.Options
@using Microsoft.JSInterop
@using WriterApp.AI.Abstractions
@using WriterApp.AI.Actions
@using WriterApp.AI.Core
@using WriterApp.Application.Commands
@using WriterApp.Application.Exporting
@using WriterApp.Application.Security
@using WriterApp.Application.State
@using WriterApp.Application.Usage
@using WriterApp.Data
@using WriterApp.Data.Subscriptions
@using WriterApp.Domain.Documents
@implements IDisposable
@implements IAsyncDisposable
@inject IJSRuntime JSRuntime
@inject ILogger<Home> Logger
@inject IAiOrchestrator AiOrchestrator
@inject IAiProposalApplier AiProposalApplier
@inject IArtifactStore ArtifactStore
@inject IAiAttachmentStore AiAttachmentStore
@inject DocumentStorageService DocumentStorage
@inject ExportService ExportService
@inject NavigationManager Navigation
@inject AppHeaderState HeaderState
@inject HttpClient Http
@inject AppDbContext DbContext
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject IAiUsageStatusService AiUsageStatusService
@inject IUserIdResolver UserIdResolver
@inject IOptions<WriterAiOptions> AiOptionsAccessor

<PageTitle>Writer</PageTitle>

@if (_hasRecoveryCandidate)
{
    <div class="recovery-banner">
        <span>We recovered unsaved changes from your last session.</span>
        <div class="recovery-actions">
            <button type="button" @onclick="OnAcceptRecovery">Use recovery</button>
            <button type="button" class="secondary" @onclick="OnDiscardRecovery">Discard</button>
        </div>
    </div>
}

<div class="editor-shell">
    <div class="editor-workspace @GetWorkspaceClass()">
        <aside class="section-panel">
            <div class="section-panel-header">
                <h2>Sections</h2>
                <div class="section-panel-actions">
                    <button type="button" @onclick="() => OnCreateSection(SectionKind.Chapter)">Add chapter</button>
                    <button type="button" @onclick="() => OnCreateSection(SectionKind.Section)">Add section</button>
                </div>
            </div>
            <ul class="section-nav-list">
                    @foreach (Section section in _orderedSections)
                    {
                        <li class="drop-zone @(GetDropZoneClass(section.SectionId, DropPosition.Before))" @ondragover="OnDragOver" @ondragover:preventDefault @ondragenter="() => OnDragEnter(section.SectionId, DropPosition.Before)" @ondrop="() => OnDrop(section.SectionId, DropPosition.Before)"></li>
                        <li class="section-nav-row @GetDraggingClass(section.SectionId)" draggable="@(_orderedSections.Count > 1 ? "true" : "false")" @ondragstart="(args) => OnDragStart(section.SectionId, args)" @ondragend="OnDragEnd">
                            <button type="button"
                                    class="section-nav-item @GetActiveSectionClass(section.SectionId)"
                                    @onclick="() => OnSectionSelected(section.SectionId)">
                                <span class="section-order">@GetSectionOrderLabel(section)</span>
                                <span class="section-title">@GetSectionTitle(section)</span>
                            </button>
                            <div class="section-nav-actions">
                                <span class="drag-handle" aria-hidden="true">:::</span>
                                <button type="button" @onclick="() => OnMoveSectionUp(section.SectionId)" disabled="@IsFirstSection(section)">Up</button>
                                <button type="button" @onclick="() => OnMoveSectionDown(section.SectionId)" disabled="@IsLastSection(section)">Down</button>
                                <button type="button" @onclick="() => OnDeleteSection(section.SectionId)" disabled="@(_orderedSections.Count <= 1)">Delete</button>
                            </div>
                        </li>
                        <li class="drop-zone @(GetDropZoneClass(section.SectionId, DropPosition.After))" @ondragover="OnDragOver" @ondragover:preventDefault @ondragenter="() => OnDragEnter(section.SectionId, DropPosition.After)" @ondrop="() => OnDrop(section.SectionId, DropPosition.After)"></li>
                    }
            </ul>
        </aside>

        <div class="editor-split @GetPreviewSplitClass()">
            <section class="editor-main">
            <div class="editor-main-header">
                <div class="editor-section-info">
                    <div class="editor-section-label">Active section</div>
                    <div class="editor-section-title">
                        @if (!string.IsNullOrWhiteSpace(GetActiveSectionNumberLabel()))
                        {
                            <span class="editor-section-number">@GetActiveSectionNumberLabel()</span>
                        }
                        <span>@GetActiveSectionTitle()</span>
                    </div>
                </div>
                <div class="document-title-field">
                    <label for="documentTitleInput">Document title</label>
                    <input id="documentTitleInput"
                           type="text"
                           value="@_documentTitleDraft"
                           @oninput="OnDocumentTitleInput" />
                </div>
                <button type="button" class="panel-toggle" @onclick="ToggleContextPanel">
                    @(_isContextPanelCollapsed ? "Show panel" : "Hide panel")
                </button>
            </div>

                <button type="button" class="preview-toggle" @onclick="TogglePreview" aria-label="Toggle preview" aria-expanded="@_isPreviewOpen">
                    @(_isPreviewOpen ? "<" : ">")
                </button>

                <div class="editor-toolbar" role="toolbar" aria-label="Editor formatting">
                <div class="editor-toolbar-group" aria-label="Text emphasis">
                    <button type="button" class="@GetActiveClass(_formattingState.IsBold)" disabled="@(!_formattingState.CanBold)" @onclick="OnBoldRequested">Bold</button>
                    <button type="button" class="@GetActiveClass(_formattingState.IsItalic)" disabled="@(!_formattingState.CanItalic)" @onclick="OnItalicRequested">Italic</button>
                    <button type="button" class="@GetActiveClass(_formattingState.IsStrike)" disabled="@(!_formattingState.CanStrike)" @onclick="OnStrikeRequested">Strike</button>
                    <button type="button" class="@GetActiveClass(_formattingState.IsCode)" disabled="@(!_formattingState.CanCode)" @onclick="OnCodeRequested">Code</button>
                </div>
                <div class="editor-toolbar-group" aria-label="Structure">
                    <button type="button" class="@GetActiveClass(_formattingState.BlockType == "paragraph")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="OnParagraphRequested">Paragraph</button>
                    <button type="button" class="@GetActiveClass(_formattingState.BlockType == "heading:1")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="() => OnHeadingRequested(1)">H1</button>
                    <button type="button" class="@GetActiveClass(_formattingState.BlockType == "heading:2")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="() => OnHeadingRequested(2)">H2</button>
                    <button type="button" class="@GetActiveClass(_formattingState.BlockType == "heading:3")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="() => OnHeadingRequested(3)">H3</button>
                    <button type="button" class="@GetActiveClass(_formattingState.BlockType == "heading:4")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="() => OnHeadingRequested(4)">H4</button>
                    <button type="button" class="@GetActiveClass(_formattingState.BlockType == "heading:5")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="() => OnHeadingRequested(5)">H5</button>
                    <button type="button" class="@GetActiveClass(_formattingState.BlockType == "heading:6")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="() => OnHeadingRequested(6)">H6</button>
                    <button type="button" disabled="@(!_formattingState.CanBlockquote)" @onclick="OnBlockquoteRequested">Blockquote</button>
                    <button type="button" disabled="@(!_formattingState.CanHorizontalRule)" @onclick="OnHorizontalRuleRequested">Horizontal rule</button>
                </div>
                <div class="editor-toolbar-group" aria-label="Alignment">
                    <button type="button" class="@GetActiveClass(_formattingState.TextAlign == "left")" @onclick='@(() => OnAlignRequested("left"))'>Align left</button>
                    <button type="button" class="@GetActiveClass(_formattingState.TextAlign == "center")" @onclick='@(() => OnAlignRequested("center"))'>Align center</button>
                    <button type="button" class="@GetActiveClass(_formattingState.TextAlign == "right")" @onclick='@(() => OnAlignRequested("right"))'>Align right</button>
                    <button type="button" @onclick="OnIndentDecreaseRequested">Indent -</button>
                    <button type="button" @onclick="OnIndentIncreaseRequested">Indent +</button>
                </div>
                <div class="editor-toolbar-group" aria-label="Lists">
                    <button type="button" disabled="@(!_formattingState.CanToggleList)" @onclick="OnBulletListRequested">Bullet list</button>
                    <button type="button" disabled="@(!_formattingState.CanToggleList)" @onclick="OnOrderedListRequested">Ordered list</button>
                </div>
                <div class="editor-toolbar-group" aria-label="Typography">
                    <label class="editor-toolbar-label" for="fontFamilySelect">Font</label>
                    <select id="fontFamilySelect" class="editor-toolbar-select" value="@_fontFamily" @onchange="OnFontFamilyChanged">
                        <option value="mixed" disabled>Mixed</option>
                        <option value="">Default</option>
                        <option value="Georgia">Georgia</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Arial">Arial</option>
                        <option value="Helvetica">Helvetica</option>
                        <option value="Courier New">Courier New</option>
                    </select>
                    <label class="editor-toolbar-label" for="fontSizeSelect">Text size</label>
                    <select id="fontSizeSelect" class="editor-toolbar-select" value="@_fontSize" @onchange="OnFontSizeChanged">
                        <option value="mixed" disabled>Mixed</option>
                        <option value="12">12px</option>
                        <option value="14">14px</option>
                        <option value="16">16px</option>
                        <option value="18">18px</option>
                        <option value="24">24px</option>
                        <option value="32">32px</option>
                    </select>
                </div>
            </div>
            <div class="editor-actions">
                <button type="button" @onclick="OnUndo" disabled="@(!_commandProcessor.CanUndo)">Undo</button>
                <button type="button" @onclick="OnRedo" disabled="@(!_commandProcessor.CanRedo)">Redo</button>
                <button type="button" @onclick="OnSave">Save</button>
                <div class="export-menu">
                    <button type="button" @onclick="ToggleExportMenu">Export Document</button>
                    @if (_isExportMenuOpen)
                    {
                        <div class="export-menu-panel">
                            <button type="button" @onclick="() => OnExportRequested(ExportKind.Document, ExportFormat.Markdown)">Export Document (Markdown)</button>
                            <button type="button" @onclick="() => OnExportRequested(ExportKind.Document, ExportFormat.Html)">Export Document (HTML)</button>
                            <button type="button" @onclick="OnExportPdfRequested">Export Document (PDF)</button>
                            <button type="button" @onclick="() => OnExportRequested(ExportKind.Synopsis, ExportFormat.Markdown)">Export Synopsis (Markdown)</button>
                            <button type="button" @onclick="() => OnExportRequested(ExportKind.Synopsis, ExportFormat.Html)">Export Synopsis (HTML)</button>
                        </div>
                    }
                </div>
                @if (CanShowAiMenu && AiOrchestrator.CanRunAction(GenerateCoverImageAction.ActionIdValue))
                {
                    <button type="button" disabled="@IsAiQuotaExceeded" @onclick="OnGenerateCoverImage">Generate cover image (mock)</button>
                }
                @if (IsAiQuotaExceeded)
                {
                    <span class="ai-quota-message">You've reached your monthly AI limit.</span>
                }
            </div>
            @if (_pendingAiProposal is not null)
            {
                <div class="ai-preview">
                    <div class="ai-preview-header">
                        <strong>AI suggestion</strong>
                        <span>@_pendingAiProposal.Instruction</span>
                        @if (_isAiStreaming)
                        {
                            <span class="ai-preview-status">Generating...</span>
                        }
                        else if (!string.IsNullOrWhiteSpace(_aiStreamError))
                        {
                            <span class="ai-preview-status error">@_aiStreamError</span>
                        }
                    </div>
                    @if (!string.IsNullOrWhiteSpace(_pendingAiProposal.ProposedText))
                    {
                        <div class="ai-preview-columns">
                            <div class="ai-preview-pane">
                                <div class="ai-preview-label">Original</div>
                                <div class="ai-preview-text">@_pendingAiProposal.OriginalText</div>
                            </div>
                            <div class="ai-preview-pane">
                                <div class="ai-preview-label">Proposed</div>
                                <div class="ai-preview-text">@_pendingAiProposal.ProposedText</div>
                            </div>
                        </div>
                    }
                    @if (!string.IsNullOrWhiteSpace(_pendingAiProposal.ImageDataUrl))
                    {
                        <div class="ai-preview-image">
                            <div class="ai-preview-label">Proposed image</div>
                            <img src="@_pendingAiProposal.ImageDataUrl" alt="Proposed cover" />
                        </div>
                    }
                    <div class="ai-preview-actions">
                        <button type="button" @onclick="OnApplyPendingAiProposal" disabled="@(!_canApplyPendingAiProposal)">Apply</button>
                        <button type="button" @onclick="OnDiscardPendingAiProposal">Discard</button>
                    </div>
                </div>
            }
            <div class="editor-surface">
                <SectionEditor @ref="_editorRef"
                               Content="@_activeSectionContent"
                               ContentChanged="OnSectionContentChanged"
                               EditorReady="OnEditorReady"
                               FormattingChanged="OnFormattingChanged"
                               OutlineChanged="OnOutlineChanged"
                               SelectionChanged="OnSelectionChanged"
                               UndoRequested="OnUndo"
                               RedoRequested="OnRedo"
                               ContextMenuRequested="OnEditorContextMenuRequested" />
            </div>
            <div class="editor-status">
                <span>@_wordCount words</span>
                <span>@_readingTime</span>
                <span class="@GetSaveStatusClass()">@GetSaveStatusLabel()</span>
                <span>@GetLastSavedLabel()</span>
                @if (_aiUsageStatus is not null)
                {
                    long usedTokens = Math.Max(0, _aiUsageStatus.QuotaTotal - _aiUsageStatus.QuotaRemaining);
                    <span>Plan: @_aiUsageStatus.Plan</span>
                    <span>AI usage: @usedTokens / @_aiUsageStatus.QuotaTotal tokens this month</span>
                    @if (!IsAiAvailable)
                    {
                        <span>AI is currently unavailable for this account.</span>
                    }
                }
            </div>
            </section>

            <aside class="preview-panel">
                <div class="preview-panel-header">
                    <h2>Preview</h2>
                </div>
                <div class="preview-panel-body">
                    <div class="document-preview">
                        @if (_previewSections is not null)
                        {
                            for (int i = 0; i < _previewSections.Count; i++)
                            {
                                string html = _previewSections[i] ?? string.Empty;
                                <section class="document-section">
                                    @((MarkupString)html)
                                </section>
                            }
                        }
                    </div>
                </div>
            </aside>
        </div>

        <aside class="context-panel @GetContextPanelClass()">
            <div class="context-panel-header">
                <h2>Context</h2>
            </div>
            <div class="context-panel-body">
            <details class="section-settings-panel" open>
                <summary>Section settings</summary>
                @{
                    Section activeSection = FindSection(_state.Document, _activeSectionId);
                }
                <div class="section-settings-grid">
                    <label for="sectionKindSelect">Kind</label>
                    <select id="sectionKindSelect" value="@activeSection.Kind" @onchange="OnSectionKindChanged">
                        <option value="@SectionKind.Chapter">Chapter</option>
                        <option value="@SectionKind.Section">Section</option>
                    </select>
                    <label for="sectionNumberingSelect">Numbering</label>
                    <select id="sectionNumberingSelect"
                            value="@activeSection.NumberingStyle"
                            disabled="@(activeSection.Kind != SectionKind.Chapter)"
                            @onchange="OnSectionNumberingStyleChanged">
                        <option value="@SectionNumberingStyle.Decimal">Decimal</option>
                        <option value="@SectionNumberingStyle.Roman">Roman</option>
                        <option value="@SectionNumberingStyle.None">None</option>
                    </select>
                    <label class="section-settings-checkbox">
                        <input type="checkbox"
                               checked="@activeSection.IncludeInNumbering"
                               disabled="@(activeSection.Kind != SectionKind.Chapter)"
                               @onchange="OnSectionIncludeChanged" />
                        Include in numbering
                    </label>
                </div>
            </details>
            <div class="outline-panel">
                <h3>Outline</h3>
                @if (_outlineItems.Count == 0)
                {
                    <div class="outline-empty">No headings</div>
                }
                else
                {
                    <ul class="outline-list">
                        @foreach (OutlineItem item in _outlineItems)
                        {
                            <li>
                                <button type="button" class="outline-item level-@item.Level" @onclick="() => OnOutlineSelected(item)">
                                    @item.Text
                                </button>
                            </li>
                        }
                    </ul>
                }
            </div>
            <details class="ai-usage-panel" open>
                <summary>AI Usage</summary>
                @if (_aiUsageStatus is null)
                {
                    <div class="ai-usage-empty">Usage details unavailable.</div>
                }
                else if (!_aiUsageStatus.UiEnabled)
                {
                    <div class="ai-usage-empty">AI is disabled.</div>
                }
                else
                {
                    long usedTokens = Math.Max(0, _aiUsageStatus.QuotaTotal - _aiUsageStatus.QuotaRemaining);
                    string quotaLabel = _aiUsageStatus.QuotaTotal.ToString(CultureInfo.InvariantCulture);
                    <div class="ai-usage-grid">
                        <div class="ai-usage-row">
                            <span>Plan</span>
                            <strong>@_aiUsageStatus.Plan</strong>
                        </div>
                        <div class="ai-usage-row">
                            <span>Remaining</span>
                            <strong>@_aiUsageStatus.QuotaRemaining.ToString(CultureInfo.InvariantCulture)</strong>
                        </div>
                        <div class="ai-usage-row">
                            <span>Quota</span>
                            <strong>@quotaLabel</strong>
                        </div>
                    </div>
                    <div class="ai-usage-progress">
                        <div class="ai-usage-progress-bar" style="width: @GetAiUsagePercent().ToString("0.##", CultureInfo.InvariantCulture)%;"></div>
                    </div>
                    <div class="ai-usage-footnote">
                        Used @usedTokens.ToString(CultureInfo.InvariantCulture) tokens this period.
                    </div>
                }
            </details>
            @if (ShouldShowUpgradePrompt)
            {
                <div class="ai-upgrade-banner">
                    <div class="ai-upgrade-text">Upgrade to Standard or Professional to continue using AI features.</div>
                    <button type="button" @onclick="OnViewPlansAsync">View plans</button>
                </div>
            }
            @if (_showPlansPanel)
            {
                <div class="ai-plans-panel">
                    <div class="ai-plans-header">
                        <strong>Plans</strong>
                        <button type="button" class="ai-plans-close" @onclick="ClosePlansPanel">Close</button>
                    </div>
                    @if (_isPlansLoading)
                    {
                        <div class="ai-usage-empty">Loading plans...</div>
                    }
                    else if (!string.IsNullOrWhiteSpace(_plansError))
                    {
                        <div class="ai-usage-empty">@_plansError</div>
                    }
                    else
                    {
                        <div class="ai-plans-list">
                            @foreach (Plan plan in _planCatalog)
                            {
                                <div class="ai-plan-card">
                                    <div class="ai-plan-title">@plan.Name</div>
                                    <div class="ai-plan-meta">Key: @plan.Key</div>
                                    <div class="ai-plan-entitlements">
                                        <div><strong>AI Enabled:</strong> @GetEntitlementValue(plan, "ai.enabled")</div>
                                        <div><strong>Monthly Tokens:</strong> @GetEntitlementValue(plan, "ai.monthly_tokens")</div>
                                        <div><strong>Daily Cap:</strong> @GetEntitlementValue(plan, "ai.daily_tokens_cap")</div>
                                        <div><strong>Cover Images:</strong> @GetEntitlementValue(plan, "ai.images.cover")</div>
                                        <div><strong>PDF Export:</strong> @GetEntitlementValue(plan, "export.pdf")</div>
                                    </div>
                                </div>
                            }
                        </div>
                    }
                </div>
            }
            @{
                IReadOnlyList<AIHistoryEntry> aiHistoryEntries = GetActiveSectionAiHistory();
            }
            @if (aiHistoryEntries.Count > 0)
            {
                <details class="ai-history-panel">
                    <summary>
                        <span>AI Changes</span>
                        <span class="ai-history-count">@aiHistoryEntries.Count</span>
                    </summary>
                    <div class="ai-history-helper">AI changes are separate from undo/redo.</div>
                    <ul class="ai-history-list">
                        @foreach (AIHistoryEntry entry in aiHistoryEntries)
                        {
                            bool isActive = IsAiHistoryEntryActive(entry);
                            bool showDetails = _aiHistoryDetailsId == entry.EditGroupId;
                            <li class="ai-history-item">
                                <div class="ai-history-meta">
                                    <span class="ai-history-badge">AI</span>
                                    <span class="ai-history-summary">@entry.OperationSummary</span>
                                </div>
                                <div class="ai-history-sub">
                                    <span>@FormatRelativeTime(entry.TimestampUtc)</span>
                                    <span class="ai-history-provider">@entry.ProviderId</span>
                                    @if (!isActive)
                                    {
                                        <span class="ai-history-rolled">Rolled back</span>
                                    }
                                </div>
                                <div class="ai-history-actions">
                                    <button type="button"
                                            disabled="@(!isActive || _isAiHistoryRollback)"
                                            @onclick="() => OnRollbackAiHistoryEntry(entry)">
                                        Undo this AI change
                                    </button>
                                    <button type="button" @onclick="() => OnToggleAiHistoryDetails(entry)">
                                        @(showDetails ? "Hide details" : "View details")
                                    </button>
                                </div>
                                @if (showDetails)
                                {
                                    <div class="ai-history-details">
                                        <div class="ai-history-details-header">
                                            <div class="ai-history-details-summary">@entry.OperationSummary</div>
                                            <div class="ai-history-details-sub">
                                                <span>@FormatRelativeTime(entry.TimestampUtc)</span>
                                                <span class="ai-history-provider">@entry.ProviderId</span>
                                            </div>
                                        </div>
                                        <div class="ai-history-details-meta">
                                            <span>Scope: @entry.TargetScope</span>
                                            <span>Section: @GetAiHistorySectionTitle(entry)</span>
                                            @if (TryGetCharacterDelta(entry, out int delta))
                                            {
                                                <span>Char delta: @FormatDelta(delta)</span>
                                            }
                                        </div>
                                        @if (!string.IsNullOrWhiteSpace(entry.Instruction))
                                        {
                                            <div class="ai-history-details-intent">
                                                <div class="ai-history-details-label">Intent</div>
                                                <div class="ai-history-details-text">@entry.Instruction</div>
                                            </div>
                                        }
                                        <div class="ai-history-details-compare">
                                            <div class="ai-history-details-block">
                                                <div class="ai-history-details-label">Before</div>
                                                <pre>@FormatHistoryText(entry.BeforeText)</pre>
                                            </div>
                                            <div class="ai-history-details-block">
                                                <div class="ai-history-details-label">After</div>
                                                <pre>@FormatHistoryText(entry.AfterText)</pre>
                                            </div>
                                        </div>
                                    </div>
                                }
                            </li>
                        }
                    </ul>
                </details>
            }
            @if (GetCoverImageDataUrl(_activeSectionId) is string coverUrl)
            {
                <div class="cover-image-preview">
                    <img src="@coverUrl" alt="Cover image" />
                </div>
            }
        </div>
    </aside>
    </div>
</div>

@if (_isContextMenuOpen)
{
    <div class="editor-context-menu-backdrop" @onclick="CloseContextMenu"></div>
    <div class="editor-context-menu"
         style="@GetContextMenuStyle()"
         tabindex="-1"
         role="menu"
         @ref="_contextMenuRef"
         @onclick:stopPropagation="true"
         @onkeydown="OnContextMenuKeyDown">
        <div class="editor-context-menu-group">
            <div class="editor-context-menu-label">Text emphasis</div>
            <button type="button" class="@GetActiveClass(_formattingState.IsBold)" disabled="@(!_formattingState.CanBold)" @onclick="() => OnContextMenuCommand(OnBoldRequested)">Bold</button>
            <button type="button" class="@GetActiveClass(_formattingState.IsItalic)" disabled="@(!_formattingState.CanItalic)" @onclick="() => OnContextMenuCommand(OnItalicRequested)">Italic</button>
            <button type="button" class="@GetActiveClass(_formattingState.IsStrike)" disabled="@(!_formattingState.CanStrike)" @onclick="() => OnContextMenuCommand(OnStrikeRequested)">Strike</button>
            <button type="button" class="@GetActiveClass(_formattingState.IsCode)" disabled="@(!_formattingState.CanCode)" @onclick="() => OnContextMenuCommand(OnCodeRequested)">Code</button>
        </div>
        <div class="editor-context-menu-group">
            <div class="editor-context-menu-label">Structure</div>
            <button type="button" class="@GetActiveClass(_formattingState.BlockType == "paragraph")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="() => OnContextMenuCommand(OnParagraphRequested)">Paragraph</button>
            <button type="button" class="@GetActiveClass(_formattingState.BlockType == "heading:1")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="() => OnContextMenuCommand(() => OnHeadingRequested(1))">Heading 1</button>
            <button type="button" class="@GetActiveClass(_formattingState.BlockType == "heading:2")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="() => OnContextMenuCommand(() => OnHeadingRequested(2))">Heading 2</button>
            <button type="button" class="@GetActiveClass(_formattingState.BlockType == "heading:3")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="() => OnContextMenuCommand(() => OnHeadingRequested(3))">Heading 3</button>
        </div>
        <div class="editor-context-menu-group">
            <div class="editor-context-menu-label">Lists</div>
            <button type="button" disabled="@(!_formattingState.CanToggleList)" @onclick="() => OnContextMenuCommand(OnBulletListRequested)">Bullet list</button>
            <button type="button" disabled="@(!_formattingState.CanToggleList)" @onclick="() => OnContextMenuCommand(OnOrderedListRequested)">Ordered list</button>
        </div>
        <div class="editor-context-menu-group">
            <div class="editor-context-menu-label">Other</div>
            <button type="button" disabled="@(!_formattingState.CanBlockquote)" @onclick="() => OnContextMenuCommand(OnBlockquoteRequested)">Blockquote</button>
        </div>
        @if (_hasAiEditsAtSelection)
        {
            <div class="editor-context-menu-group">
                <div class="editor-context-menu-label">AI History</div>
                <button type="button" @onclick="() => OnContextMenuCommand(OnRollbackAiEdit)">Revert AI change</button>
                @if (_hasMultipleAiEditsInSection)
                {
                    <button type="button" @onclick="() => OnContextMenuCommand(OnRollbackAllAiEdits)">Revert all AI changes in this section</button>
                }
            </div>
        }
        @if (_currentSelectionRange is not null && CanShowAiMenu && AiOrchestrator.CanRunAction(RewriteSelectionAction.ActionIdValue))
        {
            <div class="editor-context-menu-group">
                <div class="editor-context-menu-label">AI</div>
                @foreach (AiActionOption action in _aiActions)
                {
                    <button type="button" disabled="@IsAiQuotaExceeded" @onclick="() => OnContextMenuCommand(() => OnAiActionSelected(action))">@action.Label</button>
                }
            </div>
        }
    </div>
}

<style>
    .editor-shell {
        --section-panel-width: 500px;
        --context-panel-width: 340px;
        padding: 24px;
    }

    .recovery-banner {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        padding: 10px 14px;
        margin: 12px 24px 0;
        border-radius: 10px;
        border: 1px solid #f0d7a2;
        background: #fff7e6;
        color: #6b4b1f;
        font-size: 0.9rem;
    }

    .recovery-actions {
        display: flex;
        gap: 8px;
    }

    .recovery-banner button {
        padding: 6px 12px;
        border-radius: 6px;
        border: 1px solid #d6c79c;
        background: #f9e8c5;
        cursor: pointer;
    }

    .recovery-banner .secondary {
        background: #f5f1eb;
        border-color: #d8d4ce;
    }

    .editor-workspace {
        display: grid;
        grid-template-columns: var(--section-panel-width) minmax(0, 1fr) var(--context-panel-width);
        gap: 24px;
        align-items: start;
    }

    .section-panel {
        border: 1px solid #e3e1dd;
        border-radius: 10px;
        padding: 12px;
        background: #faf7f2;
        max-height: calc(100vh - 140px);
        overflow: auto;
    }

    .section-panel-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
        margin-bottom: 10px;
    }

    .section-panel-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        justify-content: flex-end;
    }

    .section-panel-header h2 {
        margin: 0;
        font-size: 1rem;
    }

    .editor-split {
        position: relative;
        display: grid;
        grid-template-columns: 1fr 0;
        min-width: 0;
        transition: grid-template-columns 0.3s ease;
    }

    .editor-split.is-preview-open {
        grid-template-columns: 1fr 1fr;
    }

    .editor-main {
        display: flex;
        flex-direction: column;
        gap: 12px;
        min-width: 0;
        position: relative;
        padding-right: 24px;
    }

    .editor-main-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
    }

    .document-title-field {
        display: grid;
        gap: 4px;
        min-width: 240px;
    }

    .document-title-field label {
        font-size: 0.7rem;
        letter-spacing: 0.12em;
        text-transform: uppercase;
        color: #7a7a7a;
    }

    .document-title-field input {
        border: 1px solid #d8d4ce;
        border-radius: 8px;
        padding: 6px 10px;
        font-size: 0.95rem;
        background: #ffffff;
        color: #1f2937;
        min-width: 0;
    }

    .editor-section-info {
        display: grid;
        gap: 4px;
    }

    .editor-section-label {
        font-size: 0.7rem;
        letter-spacing: 0.12em;
        text-transform: uppercase;
        color: #7a7a7a;
    }

    .editor-section-title {
        display: flex;
        align-items: baseline;
        gap: 8px;
        font-size: 1.25rem;
        font-weight: 600;
        color: #1f2937;
    }

    .editor-section-number {
        font-size: 0.9rem;
        font-weight: 600;
        color: #6b7280;
        text-transform: uppercase;
        letter-spacing: 0.06em;
    }

    .panel-toggle {
        padding: 6px 12px;
        border-radius: 20px;
        border: 1px solid #d8d4ce;
        background: #f5f1eb;
        font-size: 0.85rem;
        color: #1f2937;
        cursor: pointer;
    }

    .preview-toggle {
        position: absolute;
        top: 0;
        right: 0;
        height: 100%;
        width: 24px;
        border: 1px solid #d8d4ce;
        border-radius: 999px;
        background: #f5f1eb;
        font-size: 1rem;
        color: #1f2937;
        cursor: pointer;
        z-index: 3;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .editor-toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        padding: 8px;
        border-radius: 10px;
        border: 1px solid #e2dfda;
        background: #f5f3ef;
    }

    .editor-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
    }

    .editor-surface {
        padding: 12px;
        border-radius: 12px;
        border: 1px solid #e2dfda;
        background: #ffffff;
    }

    .editor-status {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        font-size: 0.85rem;
        color: #5b5b5b;
        padding: 8px 12px;
        border-radius: 10px;
        border: 1px solid #e2dfda;
        background: #faf7f2;
    }

    .ai-usage-summary {
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        margin-top: 8px;
        font-size: 0.9rem;
        color: #546170;
    }

    .ai-usage-note {
        margin-top: 4px;
        font-size: 0.85rem;
        color: #7a4d4d;
    }

    .preview-panel {
        border-left: 1px solid #e2dfda;
        background: #ffffff;
        display: flex;
        flex-direction: column;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease;
        min-width: 0;
    }

    .editor-split.is-preview-open .preview-panel {
        opacity: 1;
        pointer-events: auto;
    }

    .editor-split:not(.is-preview-open) .preview-panel {
        border-left: none;
    }

    .preview-panel-header {
        padding: 10px 12px;
        border-bottom: 1px solid #ececec;
        font-size: 1rem;
    }

    .preview-panel-header h2 {
        margin: 0;
        font-size: 1rem;
    }

    .preview-panel-body {
        padding: 12px;
        overflow: auto;
    }

    .context-panel {
        border: 1px solid #e3e1dd;
        border-radius: 12px;
        background: #fbfaf8;
        display: flex;
        flex-direction: column;
        max-height: calc(100vh - 140px);
        overflow: hidden;
    }

    .context-panel-header {
        padding: 10px 12px;
        border-bottom: 1px solid #e5e2dd;
    }

    .context-panel-header h2 {
        margin: 0;
        font-size: 1rem;
    }

    .context-panel-body {
        padding: 12px;
        display: grid;
        gap: 16px;
        overflow: auto;
    }

    .section-settings-panel summary {
        cursor: pointer;
        font-weight: 600;
    }

    .section-settings-grid {
        display: grid;
        gap: 8px;
        margin-top: 8px;
        font-size: 0.9rem;
    }

    .section-settings-grid select {
        padding: 6px 8px;
        border: 1px solid #d0d0d0;
        border-radius: 4px;
        background: #ffffff;
    }

    .section-settings-checkbox {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 0.85rem;
    }

    .context-panel.is-collapsed {
        display: none;
    }

    .editor-workspace.is-panel-collapsed {
        grid-template-columns: var(--section-panel-width) minmax(0, 1fr);
    }


    .section-nav-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        gap: 6px;
    }

    .section-nav-row {
        display: flex;
        align-items: center;
        gap: 6px;
    }

    .drag-handle {
        width: 28px;
        height: 28px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        cursor: grab;
        background: #fff;
        user-select: none;
    }

    .drag-handle:disabled,
    .drag-handle[aria-disabled="true"] {
        cursor: not-allowed;
        opacity: 0.5;
    }

    .drop-zone {
        height: 6px;
        border-radius: 4px;
    }

    .drop-zone.is-active {
        background: #9bb6f0;
    }

    .section-nav-row.is-dragging .section-nav-item {
        opacity: 0.6;
    }

    .section-nav-item {
        flex: 1;
        display: flex;
        align-items: center;
        gap: 8px;
        text-align: left;
        padding: 6px 8px;
        border: 1px solid transparent;
        border-radius: 4px;
        background: #fff;
        cursor: pointer;
    }

    .section-nav-item.is-active {
        border-color: #9bb6f0;
        background: #e6eefc;
    }

    .section-order {
        font-size: 0.8rem;
        color: #6b6b6b;
        min-width: 80px;
        white-space: nowrap;
    }

    .section-title {
        font-size: 0.95rem;
    }

    .section-nav-actions {
        display: flex;
        gap: 4px;
    }

    .editor-toolbar-group {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        padding-right: 10px;
        border-right: 1px solid #e3e3e3;
    }

    .editor-toolbar-group:last-child {
        padding-right: 0;
        border-right: none;
    }

    .editor-toolbar-label {
        align-self: center;
        font-size: 0.9rem;
    }

    .editor-toolbar-select {
        padding: 6px 8px;
        border: 1px solid #d0d0d0;
        border-radius: 4px;
        background: #fff;
        cursor: pointer;
    }


    .editor-actions button,
    .editor-toolbar button {
        padding: 6px 12px;
        border: 1px solid #d0d0d0;
        border-radius: 4px;
        background: #f8f8f8;
        cursor: pointer;
    }

    .section-nav-actions button,
    .section-panel-header button {
        padding: 4px 8px;
        border: 1px solid #d0d0d0;
        border-radius: 4px;
        background: #f8f8f8;
        cursor: pointer;
    }

    .section-nav-actions button:disabled,
    .section-panel-header button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .editor-actions select {
        padding: 6px 8px;
        border: 1px solid #d0d0d0;
        border-radius: 4px;
        background: #fff;
    }

    .editor-actions button:active,
    .editor-toolbar button:active {
        transform: translateY(1px);
    }

    .editor-toolbar button.is-active {
        background: #e6eefc;
        border-color: #9bb6f0;
    }

    .editor-toolbar button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .editor-context-menu-backdrop {
        position: fixed;
        inset: 0;
        z-index: 40;
    }

    .editor-context-menu {
        position: fixed;
        z-index: 41;
        min-width: 200px;
        padding: 6px;
        border: 1px solid #d6d6d6;
        border-radius: 6px;
        background: #fff;
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.12);
    }

    .editor-context-menu:focus {
        outline: none;
    }

    .editor-context-menu-group {
        display: flex;
        flex-direction: column;
        gap: 2px;
        padding: 4px 2px;
    }

    .editor-context-menu-group + .editor-context-menu-group {
        border-top: 1px solid #ececec;
        margin-top: 4px;
        padding-top: 6px;
    }

    .editor-context-menu-label {
        font-size: 0.75rem;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        color: #6b6b6b;
        padding: 4px 8px;
    }

    .editor-context-menu button {
        width: 100%;
        border: none;
        background: transparent;
        text-align: left;
        padding: 6px 8px;
        border-radius: 4px;
        cursor: pointer;
    }

    .editor-context-menu button:hover:not(:disabled) {
        background: #f0f3f8;
    }

    .editor-context-menu button.is-active {
        background: #e6eefc;
        color: #1f2a44;
    }

    .editor-context-menu button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .dirty-indicator {
        font-weight: 600;
        color: #b45309;
    }

    .clean-indicator {
        color: #4b5563;
    }

    .saving-indicator {
        color: #6b4b1f;
        font-weight: 600;
    }

    .ai-edit-range {
        background: rgba(255, 204, 102, 0.25);
        border-radius: 2px;
    }

    .ai-edit-range.is-active {
        background: rgba(255, 204, 102, 0.55);
    }

    .ai-preview {
        border: 1px solid #e3e3e3;
        border-radius: 6px;
        padding: 12px;
        background: #fffaf0;
        display: grid;
        gap: 10px;
    }

    .ai-preview-header {
        display: flex;
        gap: 8px;
        align-items: baseline;
        font-size: 0.95rem;
    }

    .ai-preview-status {
        margin-left: auto;
        font-size: 0.85rem;
        color: #8a6d3b;
    }

    .ai-preview-status.error {
        color: #b00020;
    }

    .ai-preview-columns {
        display: grid;
        gap: 12px;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    }

    .ai-preview-pane {
        border: 1px solid #e8e8e8;
        border-radius: 4px;
        padding: 8px;
        background: #fff;
    }

    .ai-preview-label {
        font-size: 0.85rem;
        color: #6b6b6b;
        margin-bottom: 4px;
    }

    .ai-preview-text {
        font-size: 0.95rem;
        white-space: pre-wrap;
    }

    .ai-preview-image {
        border: 1px solid #e8e8e8;
        border-radius: 4px;
        padding: 8px;
        background: #fff;
        display: grid;
        gap: 6px;
    }

    .ai-preview-image img {
        max-width: 100%;
        height: auto;
        border-radius: 4px;
        border: 1px solid #eee;
    }

    .ai-preview-actions {
        display: flex;
        gap: 8px;
    }

    .editor-surface .ProseMirror {
        min-height: 320px;
        padding: 8px;
        border: none;
        background: transparent;
    }

    .document-preview {
        width: 100%;
        padding: 20px 22px;
        line-height: 1.6;
        font-family: "Georgia", "Times New Roman", serif;
        background: #fff;
        color: #1e1e1e;
        border: 1px solid #e2e2e2;
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.05);
    }

    .cover-image-preview {
        width: 100%;
        margin: 0 0 16px;
        padding: 12px;
        background: #fff;
        border: 1px solid #e2e2e2;
        border-radius: 8px;
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.05);
    }

    .cover-image-preview img {
        width: 100%;
        height: auto;
        display: block;
        border-radius: 6px;
    }

    .document-section {
        margin-bottom: 28px;
        padding-bottom: 8px;
        border-bottom: 1px solid #f0f0f0;
    }

    .document-section:last-child {
        border-bottom: none;
        margin-bottom: 0;
        padding-bottom: 0;
    }

    .outline-panel {
        margin-bottom: 16px;
        padding: 12px;
        border: 1px solid #ececec;
        border-radius: 6px;
        background: #fafafa;
    }

    .outline-panel h3 {
        margin: 0 0 8px 0;
        font-size: 1rem;
    }

    .outline-list {
        list-style: none;
        margin: 0;
        padding: 0;
    }

    .outline-item {
        display: block;
        width: 100%;
        text-align: left;
        padding: 4px 6px;
        border: 1px solid transparent;
        border-radius: 4px;
        background: transparent;
        cursor: pointer;
    }

    .outline-item:hover {
        background: #f0f3f8;
        border-color: #d7dbe2;
    }

    .outline-item.level-1 { padding-left: 4px; }
    .outline-item.level-2 { padding-left: 16px; }
    .outline-item.level-3 { padding-left: 28px; }
    .outline-item.level-4 { padding-left: 40px; }
    .outline-item.level-5 { padding-left: 52px; }
    .outline-item.level-6 { padding-left: 64px; }

    .outline-empty {
        font-size: 0.9rem;
        color: #7a7a7a;
    }

    .ai-usage-panel {
        margin-bottom: 16px;
        padding: 12px;
        border: 1px solid #ececec;
        border-radius: 6px;
        background: #fbfbfb;
    }

    .ai-usage-panel summary {
        cursor: pointer;
        font-weight: 600;
        margin-bottom: 10px;
    }

    .ai-usage-grid {
        display: grid;
        gap: 6px;
    }

    .ai-usage-row {
        display: flex;
        justify-content: space-between;
        gap: 8px;
        font-size: 0.9rem;
    }

    .ai-usage-empty {
        font-size: 0.9rem;
        color: #6b7280;
    }

    .ai-usage-progress {
        margin-top: 10px;
        height: 8px;
        border-radius: 999px;
        background: #e5e7eb;
        overflow: hidden;
    }

    .ai-usage-progress-bar {
        height: 100%;
        background: #2563eb;
    }

    .ai-usage-footnote {
        margin-top: 6px;
        font-size: 0.8rem;
        color: #6b7280;
    }

    .ai-quota-message {
        margin-left: 12px;
        font-size: 0.85rem;
        color: #b45309;
    }

    .ai-upgrade-banner {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        padding: 10px 12px;
        margin-bottom: 16px;
        border: 1px solid #f1d1a5;
        border-radius: 8px;
        background: #fff7e6;
        font-size: 0.9rem;
        color: #7a5a24;
    }

    .ai-upgrade-banner button {
        padding: 6px 10px;
        border-radius: 6px;
        border: 1px solid #d6c79c;
        background: #f9e8c5;
        cursor: pointer;
    }

    .ai-plans-panel {
        margin-bottom: 16px;
        padding: 12px;
        border: 1px solid #ececec;
        border-radius: 8px;
        background: #ffffff;
    }

    .ai-plans-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
    }

    .ai-plans-close {
        border: none;
        background: transparent;
        color: #6b7280;
        cursor: pointer;
    }

    .ai-plans-list {
        display: grid;
        gap: 10px;
    }

    .ai-plan-card {
        border: 1px solid #edf0f5;
        border-radius: 8px;
        padding: 10px;
        background: #f9fafb;
    }

    .ai-plan-title {
        font-weight: 600;
        margin-bottom: 4px;
    }

    .ai-plan-meta {
        font-size: 0.8rem;
        color: #6b7280;
        margin-bottom: 6px;
    }

    .ai-plan-entitlements {
        display: grid;
        gap: 4px;
        font-size: 0.85rem;
        color: #374151;
    }

    .ai-history-panel {
        margin: 1.5rem 0;
        padding: 0.75rem 0.9rem;
        border-radius: 12px;
        border: 1px solid #e2e6ee;
        background: #f8f9fb;
    }

    .ai-history-panel summary {
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-weight: 600;
        cursor: pointer;
    }

    .ai-history-count {
        font-size: 0.8rem;
        color: #5f6b7a;
    }

    .ai-history-helper {
        margin: 0.5rem 0 0.75rem;
        font-size: 0.85rem;
        color: #6b7280;
    }

    .ai-history-list {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
    }

    .ai-history-item {
        padding: 0.7rem 0.8rem;
        border-radius: 10px;
        background: #ffffff;
        border: 1px solid #edf0f5;
    }

    .ai-history-meta {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-weight: 600;
    }

    .ai-history-badge {
        font-size: 0.7rem;
        padding: 0.15rem 0.45rem;
        border-radius: 999px;
        background: #1f2937;
        color: #ffffff;
        letter-spacing: 0.04em;
    }

    .ai-history-summary {
        font-size: 0.95rem;
        color: #111827;
    }

    .ai-history-sub {
        margin-top: 0.35rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        font-size: 0.8rem;
        color: #6b7280;
    }

    .ai-history-provider {
        text-transform: uppercase;
        letter-spacing: 0.06em;
        font-weight: 600;
    }

    .ai-history-rolled {
        color: #a33a3a;
        font-weight: 600;
    }

    .ai-history-actions {
        margin-top: 0.6rem;
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
    }

    .ai-history-details {
        margin-top: 0.75rem;
        padding-top: 0.75rem;
        border-top: 1px solid #edf0f5;
        display: flex;
        flex-direction: column;
        gap: 0.6rem;
    }

    .ai-history-details-header {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
    }

    .ai-history-details-summary {
        font-weight: 600;
        color: #111827;
    }

    .ai-history-details-sub {
        display: flex;
        gap: 0.5rem;
        font-size: 0.8rem;
        color: #6b7280;
    }

    .ai-history-details-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 0.6rem;
        font-size: 0.8rem;
        color: #4b5563;
    }

    .ai-history-details-compare {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 0.6rem;
    }

    .ai-history-details-block {
        padding: 0.5rem;
        border-radius: 8px;
        background: #f9fafb;
        border: 1px solid #eef2f7;
    }

    .ai-history-details-label {
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: #6b7280;
        margin-bottom: 0.35rem;
    }

    .ai-history-details-block pre {
        margin: 0;
        white-space: pre-wrap;
        font-family: "Georgia", serif;
        font-size: 0.85rem;
        color: #111827;
    }

    .ai-history-details-intent {
        padding: 0.5rem;
        border-radius: 8px;
        background: #fff7ed;
        border: 1px solid #fde3c5;
    }

    .export-menu {
        position: relative;
        display: inline-block;
    }

    .export-menu-panel {
        position: absolute;
        top: calc(100% + 0.35rem);
        right: 0;
        min-width: 180px;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        padding: 0.5rem;
        border-radius: 8px;
        background: #ffffff;
        border: 1px solid #e5e7eb;
        box-shadow: 0 12px 24px rgba(15, 23, 42, 0.12);
        z-index: 20;
    }

    @@media (max-width: 1200px) {
        .editor-shell {
            --section-panel-width: 360px;
        }

        .editor-workspace {
            grid-template-columns: var(--section-panel-width) minmax(0, 1fr);
        }

        .context-panel {
            display: none;
        }
    }
</style>

@code {
    [Parameter]
    public string? DocumentId { get; set; }

    private DocumentState _state;
    private CommandProcessor _commandProcessor;
    private readonly Action _onChangedHandler;
    private readonly List<string> _previewSections = new();
    private readonly List<OutlineItem> _outlineItems = new();
    private readonly List<Section> _orderedSections = new();
    private readonly SectionNumberingService _numberingService = new();
    private IReadOnlyDictionary<Guid, SectionNumberingInfo> _sectionNumbering = new Dictionary<Guid, SectionNumberingInfo>();
    private SectionEditor? _editorRef;
    private Guid _activeSectionId;
    private string _activeSectionContent = string.Empty;
    private bool _suppressEditorEvent;
    private bool _skipNextEditorSync;
    private IJSObjectReference? _editorInstance;
    private IJSObjectReference? _commandsModule;
    private IJSObjectReference? _exportModule;
    private bool _disposed;
    private string _fontSize = "16";
    private string _fontFamily = string.Empty;
    private EditorFormattingState _formattingState = new()
    {
        CanBold = true,
        CanItalic = true,
        CanStrike = true,
        CanCode = true,
        CanApplyHeading = true,
        CanToggleList = true,
        CanBlockquote = true,
        CanHorizontalRule = true,
        TextAlign = "left"
    };
    private int _wordCount;
    private string _readingTime = "0 min read";
    private bool _isDirty;
    private DateTime _lastSavedUtc;
    private DateTime _lastAutosaveUtc;
    private AutosaveStatus _autosaveStatus = AutosaveStatus.Idle;
    private CancellationTokenSource? _autosaveCts;
    private bool _isManualSaveInProgress;
    private string _documentTitleDraft = string.Empty;
    private bool _hasRecoveryCandidate;
    private DocumentStorageService.DocumentAutosave? _recoveryCandidate;
    private bool _suppressDirtyUpdate;
    private Guid? _draggingSectionId;
    private Guid? _dropTargetSectionId;
    private DropPosition? _dropPosition;
    private bool _isContextMenuOpen;
    private bool _isContextPanelCollapsed;
    private bool _isPreviewOpen;
    private double _contextMenuX;
    private double _contextMenuY;
    private ElementReference _contextMenuRef;
    private bool _shouldFocusContextMenu;
    private TextRange? _currentSelectionRange;
    private bool _hasAiEditsAtSelection;
    private bool _hasMultipleAiEditsInSection;
    private Guid? _aiRollbackGroupId;
    private bool _isAiHistoryRollback;
    private Guid? _aiHistoryDetailsId;
    private bool _isReordering;
    private PendingAiProposal? _pendingAiProposal;
    private CancellationTokenSource? _aiStreamCts;
    private bool _isAiStreaming;
    private bool _isExportMenuOpen;
    private string? _aiStreamError;
    private string _streamedText = string.Empty;
    private string? _streamedImageReference;
    private string? _loadedDocumentId;
    private bool _pendingDocumentLoad;
    private AiUsageStatusDto? _aiUsageStatus;
    private readonly List<Plan> _planCatalog = new();
    private bool _showPlansPanel;
    private bool _isPlansLoading;
    private string? _plansError;
    private CancellationTokenSource? _aiUsageRefreshCts;
    private bool _aiUsageRefreshInProgress;
    private Task? _aiUsageRefreshTask;
    private bool _canShowAiMenu;
    private bool? _lastAiMenuVisibility;
    private readonly List<AiActionOption> _aiActions = new()
    {
        new AiActionOption("Rewrite (Neutral)", "Rewrite (Neutral)", AiActionScope.Selection, new Dictionary<string, object?>
        {
            ["tone"] = "Neutral",
            ["length"] = "Same",
            ["preserve_terms"] = true
        }),
        new AiActionOption("Rewrite (Formal)", "Rewrite (Formal)", AiActionScope.Selection, new Dictionary<string, object?>
        {
            ["tone"] = "Formal",
            ["length"] = "Same",
            ["preserve_terms"] = true
        }),
        new AiActionOption("Rewrite (Casual)", "Rewrite (Casual)", AiActionScope.Selection, new Dictionary<string, object?>
        {
            ["tone"] = "Casual",
            ["length"] = "Same",
            ["preserve_terms"] = true
        }),
        new AiActionOption("Rewrite (Executive)", "Rewrite (Executive)", AiActionScope.Selection, new Dictionary<string, object?>
        {
            ["tone"] = "Executive",
            ["length"] = "Same",
            ["preserve_terms"] = true
        }),
        new AiActionOption("Shorten (Neutral)", "Shorten (Neutral)", AiActionScope.Selection, new Dictionary<string, object?>
        {
            ["tone"] = "Neutral",
            ["length"] = "Shorter",
            ["preserve_terms"] = true
        }),
        new AiActionOption("Fix grammar (Neutral)", "Fix grammar (Neutral)", AiActionScope.Selection, new Dictionary<string, object?>
        {
            ["tone"] = "Neutral",
            ["length"] = "Same",
            ["preserve_terms"] = true
        }),
        new AiActionOption("Change tone (Friendly)", "Change tone (Friendly)", AiActionScope.Selection, new Dictionary<string, object?>
        {
            ["tone"] = "Friendly",
            ["length"] = "Same",
            ["preserve_terms"] = true
        }),
        new AiActionOption("Change tone (Technical)", "Change tone (Technical)", AiActionScope.Selection, new Dictionary<string, object?>
        {
            ["tone"] = "Technical",
            ["length"] = "Same",
            ["preserve_terms"] = true
        })
    };
    private static readonly TimeSpan AutosaveDebounce = TimeSpan.FromSeconds(2.5);
    public Home()
    {
        Document document = DocumentFactory.CreateNewDocument();
        _state = new DocumentState(document);
        _commandProcessor = new CommandProcessor(_state);
        _onChangedHandler = () => _ = HandleDocumentChangedAsync();
        _state.OnChanged += _onChangedHandler;

        if (document.Chapters.Count > 0 && document.Chapters[0].Sections.Count > 0)
        {
            _activeSectionId = document.Chapters[0].Sections[0].SectionId;
        }

        _lastSavedUtc = document.Metadata.ModifiedUtc;
    }

    protected override void OnInitialized()
    {
        RefreshFromDocument(_state.Document);
        _lastSavedUtc = _state.Document.Metadata.ModifiedUtc;
        _isDirty = false;
        _autosaveStatus = AutosaveStatus.Idle;
        _lastAutosaveUtc = default;
        _hasRecoveryCandidate = false;
        _recoveryCandidate = null;
        UpdateAiMenuVisibility();
    }

    protected override async Task OnInitializedAsync()
    {
        await LoadAiUsageStatusAsync();
        StartAiUsageRefreshLoop();
    }

    protected override void OnParametersSet()
    {
        if (DocumentId is null)
        {
            _pendingDocumentLoad = true;
            return;
        }

        if (!string.Equals(_loadedDocumentId, DocumentId, StringComparison.Ordinal))
        {
            _pendingDocumentLoad = true;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_pendingDocumentLoad)
        {
            _pendingDocumentLoad = false;
            await LoadDocumentFromRouteAsync(DocumentId);
        }

        if (_shouldFocusContextMenu)
        {
            _shouldFocusContextMenu = false;
            await _contextMenuRef.FocusAsync();
        }
    }

    private Task OnSectionContentChanged(string html)
    {
        return ExecuteSafeAsync("OnSectionContentChanged", () =>
        {
            if (_suppressEditorEvent || _disposed)
            {
                return Task.CompletedTask;
            }

            string content = html ?? string.Empty;
            Section section = FindSection(_state.Document, _activeSectionId);
            if (string.Equals(section.Content.Value, content, StringComparison.Ordinal))
            {
                return Task.CompletedTask;
            }

            _skipNextEditorSync = true;
            _commandProcessor.Execute(new UpdateSectionContentCommand(_activeSectionId, content));
            return Task.CompletedTask;
        });
    }

    private Task OnUndo()
    {
        return ExecuteSafeAsync("OnUndo", () =>
        {
            if (_commandProcessor.CanUndo)
            {
                _commandProcessor.Undo();
                return InvokeCommandAsync("focusEditor");
            }

            return Task.CompletedTask;
        });
    }

    private Task OnRedo()
    {
        return ExecuteSafeAsync("OnRedo", () =>
        {
            if (_commandProcessor.CanRedo)
            {
                _commandProcessor.Redo();
                return InvokeCommandAsync("focusEditor");
            }

            return Task.CompletedTask;
        });
    }

    private Task OnFontSizeChanged(ChangeEventArgs args)
    {
        return ExecuteSafeAsync("OnFontSizeChanged", async () =>
        {
            if (args.Value is null)
            {
                return;
            }

            string? value = args.Value.ToString();
            if (string.Equals(value, "mixed", StringComparison.Ordinal))
            {
                return;
            }

            if (int.TryParse(value, out int size))
            {
                _fontSize = size.ToString(CultureInfo.InvariantCulture);
                await InvokeCommandAsync("setFontSize", size);
            }
        });
    }

    private Task OnFontFamilyChanged(ChangeEventArgs args)
    {
        return ExecuteSafeAsync("OnFontFamilyChanged", async () =>
        {
            string? family = args.Value?.ToString();
            _fontFamily = family ?? string.Empty;

            if (string.Equals(_fontFamily, "mixed", StringComparison.Ordinal))
            {
                return;
            }

            if (string.IsNullOrWhiteSpace(_fontFamily))
            {
                await InvokeCommandAsync("clearFontFamily");
                return;
            }

            await InvokeCommandAsync("setFontFamily", _fontFamily);
        });
    }

    private void OnDocumentTitleInput(ChangeEventArgs args)
    {
        ExecuteSafe("OnDocumentTitleInput", () =>
        {
            _documentTitleDraft = args.Value?.ToString() ?? string.Empty;
            HeaderState.DocumentTitle = string.IsNullOrWhiteSpace(_documentTitleDraft)
                ? "Untitled"
                : _documentTitleDraft;
            _isDirty = true;
            ScheduleAutosave();
        });
    }

    private Task OnSectionKindChanged(ChangeEventArgs args)
    {
        return ExecuteSafeAsync("OnSectionKindChanged", () =>
        {
            string? value = args.Value?.ToString();
            if (string.IsNullOrWhiteSpace(value))
            {
                return Task.CompletedTask;
            }

            if (!Enum.TryParse(value, out SectionKind kind))
            {
                return Task.CompletedTask;
            }

            return UpdateSectionSettings(kind: kind);
        });
    }

    private Task OnSectionIncludeChanged(ChangeEventArgs args)
    {
        return ExecuteSafeAsync("OnSectionIncludeChanged", () =>
        {
            bool include = false;
            if (args.Value is bool boolValue)
            {
                include = boolValue;
            }
            else if (args.Value is string rawValue)
            {
                bool.TryParse(rawValue, out include);
            }

            return UpdateSectionSettings(include: include);
        });
    }

    private Task OnSectionNumberingStyleChanged(ChangeEventArgs args)
    {
        return ExecuteSafeAsync("OnSectionNumberingStyleChanged", () =>
        {
            string? value = args.Value?.ToString();
            if (string.IsNullOrWhiteSpace(value))
            {
                return Task.CompletedTask;
            }

            if (!Enum.TryParse(value, out SectionNumberingStyle style))
            {
                return Task.CompletedTask;
            }

            return UpdateSectionSettings(style: style);
        });
    }

    private Task UpdateSectionSettings(SectionKind? kind = null, bool? include = null, SectionNumberingStyle? style = null)
    {
        Section section = FindSection(_state.Document, _activeSectionId);

        SectionKind nextKind = kind ?? section.Kind;
        bool nextInclude = include ?? section.IncludeInNumbering;
        SectionNumberingStyle nextStyle = style ?? section.NumberingStyle;

        if (nextKind != SectionKind.Chapter)
        {
            nextInclude = false;
            nextStyle = SectionNumberingStyle.None;
        }
        else if (kind.HasValue && nextKind == SectionKind.Chapter)
        {
            if (!include.HasValue)
            {
                nextInclude = true;
            }

            if (!style.HasValue || style.Value == SectionNumberingStyle.None)
            {
                nextStyle = SectionNumberingStyle.Decimal;
            }
        }

        if (nextKind == section.Kind
            && nextInclude == section.IncludeInNumbering
            && nextStyle == section.NumberingStyle)
        {
            return Task.CompletedTask;
        }

        _commandProcessor.Execute(new UpdateSectionMetadataCommand(_activeSectionId, nextKind, nextInclude, nextStyle));
        return Task.CompletedTask;
    }


    private Task OnSectionSelected(Guid sectionId)
    {
        return ExecuteSafeAsync("OnSectionSelected", async () =>
        {
            if (sectionId == _activeSectionId)
            {
                return;
            }

            _commandProcessor.ClearHistory();
            _activeSectionId = sectionId;
            _pendingAiProposal = null;
            _skipNextEditorSync = false;
            _suppressDirtyUpdate = true;
            _currentSelectionRange = null;
            _state.NotifyChanged();
            await InvokeCommandAsync("focusEditor");
        });
    }

    private Task OnMoveSectionUp(Guid sectionId)
    {
        return ExecuteSafeAsync("OnMoveSectionUp", () => MoveSectionAsync(sectionId, -1));
    }

    private Task OnMoveSectionDown(Guid sectionId)
    {
        return ExecuteSafeAsync("OnMoveSectionDown", () => MoveSectionAsync(sectionId, 1));
    }

    private Task OnCreateSection(SectionKind kind)
    {
        return ExecuteSafeAsync("OnCreateSection", async () =>
        {
            Chapter chapter = GetPrimaryChapter();
            List<Section> ordered = _orderedSections.Count > 0
                ? new List<Section>(_orderedSections)
                : chapter.Sections.OrderBy(section => section.Order).ToList();

            int insertIndex = ordered.FindIndex(section => section.SectionId == _activeSectionId);
            if (insertIndex < 0)
            {
                insertIndex = ordered.Count - 1;
            }

            Section newSection = new()
            {
                SectionId = Guid.NewGuid(),
                Order = insertIndex + 1,
                Title = string.Empty,
                Kind = kind,
                IncludeInNumbering = kind == SectionKind.Chapter,
                NumberingStyle = kind == SectionKind.Chapter ? SectionNumberingStyle.Decimal : SectionNumberingStyle.None,
                Content = new SectionContent { Format = "html", Value = "<p></p>" },
                Stats = new SectionStats(),
                Flags = new SectionFlags(),
                AI = new SectionAIInfo(),
                CreatedUtc = DateTime.UtcNow,
                ModifiedUtc = DateTime.UtcNow
            };

            ordered.Insert(insertIndex + 1, newSection);
            chapter.Sections.Add(newSection);
            ApplySectionOrdering(ordered, chapter);

            _activeSectionId = newSection.SectionId;
            _commandProcessor.ClearHistory();
            _state.NotifyChanged();
            await InvokeCommandAsync("focusEditor");
        });
    }

    private Task OnDeleteSection(Guid sectionId)
    {
        return ExecuteSafeAsync("OnDeleteSection", async () =>
        {
            if (_orderedSections.Count <= 1)
            {
                return;
            }

            bool confirmed;
            try
            {
                confirmed = await JSRuntime.InvokeAsync<bool>("confirm", "Delete this section?");
            }
            catch (JSException ex)
            {
                Logger.LogWarning(ex, "Delete confirmation failed.");
                return;
            }

            if (!confirmed)
            {
                return;
            }

            Chapter chapter = GetPrimaryChapter();
            List<Section> ordered = _orderedSections.Count > 0
                ? new List<Section>(_orderedSections)
                : chapter.Sections.OrderBy(section => section.Order).ToList();

            int removeIndex = ordered.FindIndex(section => section.SectionId == sectionId);
            if (removeIndex < 0)
            {
                return;
            }

            ordered.RemoveAt(removeIndex);
            chapter.Sections.RemoveAll(section => section.SectionId == sectionId);
            ApplySectionOrdering(ordered, chapter);

            if (sectionId == _activeSectionId)
            {
                int nextIndex = Math.Min(removeIndex, ordered.Count - 1);
                _activeSectionId = ordered[nextIndex].SectionId;
            }

            _commandProcessor.ClearHistory();
            _state.NotifyChanged();
            await InvokeCommandAsync("focusEditor");
        });
    }

    private Task MoveSectionAsync(Guid sectionId, int direction)
    {
        return ExecuteSafeAsync("MoveSectionAsync", async () =>
        {
            if (_orderedSections.Count <= 1 || direction == 0)
            {
                return;
            }

            Chapter chapter = GetPrimaryChapter();
            List<Section> ordered = _orderedSections.Count > 0
                ? new List<Section>(_orderedSections)
                : chapter.Sections.OrderBy(section => section.Order).ToList();

            int index = ordered.FindIndex(section => section.SectionId == sectionId);
            int targetIndex = index + direction;
            if (index < 0 || targetIndex < 0 || targetIndex >= ordered.Count)
            {
                return;
            }

            Section section = ordered[index];
            ordered.RemoveAt(index);
            ordered.Insert(targetIndex, section);

            _commandProcessor.Execute(new ReorderSectionsCommand(
                chapter.ChapterId,
                ordered.Select(entry => entry.SectionId).ToList()));
        });
    }

    private void OnDragStart(Guid sectionId, DragEventArgs args)
    {
        ExecuteSafe("OnDragStart", () =>
        {
            Logger.LogInformation("DragStart: section {SectionId}", sectionId);
            if (_orderedSections.Count <= 1)
            {
                Logger.LogInformation("DragStart ignored: only one section.");
                return;
            }

            _draggingSectionId = sectionId;
            _dropTargetSectionId = null;
            _dropPosition = null;

            if (args.DataTransfer is not null)
            {
                args.DataTransfer.DropEffect = "move";
                args.DataTransfer.EffectAllowed = "move";
            }

            _ = InvokeAsync(StateHasChanged);
        });
    }

    private void OnDragEnd(DragEventArgs args)
    {
        ExecuteSafe("OnDragEnd", () =>
        {
            Logger.LogInformation("DragEnd: dragging {SectionId}", _draggingSectionId);
            _draggingSectionId = null;
            _dropTargetSectionId = null;
            _dropPosition = null;
            _ = InvokeAsync(StateHasChanged);
        });
    }

    private void OnDragEnter(Guid targetSectionId, DropPosition position)
    {
        ExecuteSafe("OnDragEnter", () =>
        {
            Logger.LogInformation("DragEnter: target {TargetSectionId} position {Position}", targetSectionId, position);
            if (_draggingSectionId is null || _draggingSectionId == targetSectionId)
            {
                Logger.LogInformation("DragEnter ignored: dragging {DraggingSectionId}", _draggingSectionId);
                return;
            }

            _dropTargetSectionId = targetSectionId;
            _dropPosition = position;
            _ = InvokeAsync(StateHasChanged);
        });
    }

    private void OnDragOver(DragEventArgs args)
    {
        ExecuteSafe("OnDragOver", () =>
        {
            if (args.DataTransfer is not null)
            {
                args.DataTransfer.DropEffect = "move";
            }
        });
    }

    private Task OnDrop(Guid targetSectionId, DropPosition position)
    {
        return ExecuteSafeAsync("OnDrop", async () =>
        {
            Logger.LogInformation("Drop: target {TargetSectionId} position {Position} dragging {DraggingSectionId}", targetSectionId, position, _draggingSectionId);
            if (_draggingSectionId is null || _draggingSectionId == targetSectionId)
            {
                Logger.LogInformation("Drop ignored: invalid dragging state.");
                return;
            }

            Guid sourceSectionId = _draggingSectionId.Value;
            _draggingSectionId = null;
            _dropTargetSectionId = null;
            _dropPosition = null;

            Chapter chapter = GetPrimaryChapter();
            List<Section> ordered = new(_orderedSections);
            int sourceIndex = ordered.FindIndex(section => section.SectionId == sourceSectionId);
            int targetIndex = ordered.FindIndex(section => section.SectionId == targetSectionId);
            if (sourceIndex < 0 || targetIndex < 0)
            {
                Logger.LogWarning("Drop aborted: sourceIndex {SourceIndex} targetIndex {TargetIndex}", sourceIndex, targetIndex);
                return;
            }

            Section moving = ordered[sourceIndex];
            ordered.RemoveAt(sourceIndex);
            if (sourceIndex < targetIndex)
            {
                targetIndex -= 1;
            }

            int insertIndex = position == DropPosition.Before ? targetIndex : targetIndex + 1;
            insertIndex = Math.Clamp(insertIndex, 0, ordered.Count);
            Logger.LogInformation("Drop reorder: source {SourceIndex} target {TargetIndex} insert {InsertIndex}", sourceIndex, targetIndex, insertIndex);
            ordered.Insert(insertIndex, moving);

            _commandProcessor.Execute(new ReorderSectionsCommand(
                chapter.ChapterId,
                ordered.Select(entry => entry.SectionId).ToList()));
        });
    }

    private string GetDropZoneClass(Guid sectionId, DropPosition position)
    {
        if (_dropTargetSectionId == sectionId && _dropPosition == position)
        {
            return "is-active";
        }

        return string.Empty;
    }

    private string GetDraggingClass(Guid sectionId)
    {
        return _draggingSectionId == sectionId ? "is-dragging" : string.Empty;
    }

    private enum DropPosition
    {
        Before,
        After
    }

    private enum AutosaveStatus
    {
        Idle,
        Saving,
        Failed
    }

    private Chapter GetPrimaryChapter()
    {
        if (_state.Document.Chapters.Count == 0)
        {
            Chapter chapter = new() { Order = 0, Title = "Draft" };
            _state.Document.Chapters.Add(chapter);
            return chapter;
        }

        return _state.Document.Chapters[0];
    }

    private void ApplySectionOrdering(List<Section> ordered, Chapter chapter)
    {
        Dictionary<Guid, Section> updates = new();
        for (int i = 0; i < ordered.Count; i++)
        {
            Section updated = ordered[i] with { Order = i };
            updates[updated.SectionId] = updated;
        }

        for (int i = 0; i < chapter.Sections.Count; i++)
        {
            Section section = chapter.Sections[i];
            if (updates.TryGetValue(section.SectionId, out Section updated))
            {
                chapter.Sections[i] = updated;
            }
        }
    }

    private bool IsFirstSection(Section section) => _orderedSections.Count == 0 || _orderedSections[0].SectionId == section.SectionId;

    private bool IsLastSection(Section section) => _orderedSections.Count == 0 || _orderedSections[^1].SectionId == section.SectionId;

    private string GetActiveSectionClass(Guid sectionId) => sectionId == _activeSectionId ? "is-active" : string.Empty;

    private string GetSectionOrderLabel(Section section)
    {
        if (_sectionNumbering.TryGetValue(section.SectionId, out SectionNumberingInfo info) && info.IsNumbered)
        {
            return section.Kind == SectionKind.Chapter
                ? $"Chapter {info.Number}"
                : info.Number ?? string.Empty;
        }

        return section.Kind == SectionKind.Chapter ? "Chapter" : "Section";
    }

    private string GetSectionTitle(Section section)
    {
        if (!string.IsNullOrWhiteSpace(section.Title))
        {
            return section.Title;
        }

        string? derived = DeriveTitleFromSection(section.Content.Value);
        return string.IsNullOrWhiteSpace(derived) ? "Untitled section" : derived;
    }

    private string GetActiveSectionTitle()
    {
        Section activeSection = FindSection(_state.Document, _activeSectionId);
        return GetSectionTitle(activeSection);
    }

    private string GetActiveSectionNumberLabel()
    {
        Section activeSection = FindSection(_state.Document, _activeSectionId);
        if (_sectionNumbering.TryGetValue(activeSection.SectionId, out SectionNumberingInfo info) && info.IsNumbered)
        {
            return activeSection.Kind == SectionKind.Chapter
                ? $"Chapter {info.Number}"
                : info.Number ?? string.Empty;
        }

        return string.Empty;
    }

    private void ToggleContextPanel()
    {
        _isContextPanelCollapsed = !_isContextPanelCollapsed;
    }

    private string GetContextPanelClass() => _isContextPanelCollapsed ? "is-collapsed" : string.Empty;

    private string GetWorkspaceClass() => _isContextPanelCollapsed ? "is-panel-collapsed" : string.Empty;

    private void TogglePreview()
    {
        _isPreviewOpen = !_isPreviewOpen;
    }

    private string GetPreviewSplitClass() => _isPreviewOpen ? "is-preview-open" : string.Empty;

    private static string? DeriveTitleFromSection(string? html)
    {
        if (string.IsNullOrWhiteSpace(html))
        {
            return null;
        }

        Match match = Regex.Match(html, "<h[1-6][^>]*>(.*?)</h[1-6]>", RegexOptions.IgnoreCase | RegexOptions.Singleline);
        if (!match.Success)
        {
            return null;
        }

        string plain = ExtractPlainText(match.Groups[1].Value);
        if (string.IsNullOrWhiteSpace(plain))
        {
            return null;
        }

        plain = Regex.Replace(plain, @"\s+", " ").Trim();
        if (plain.Length > 60)
        {
            plain = plain.Substring(0, 60).Trim();
        }

        return plain;
    }

    private Task OnOutlineChanged(List<OutlineItem> outline)
    {
        return ExecuteSafeAsync("OnOutlineChanged", () =>
        {
            if (_disposed)
            {
                return Task.CompletedTask;
            }

            _outlineItems.Clear();
            if (outline is not null)
            {
                _outlineItems.AddRange(outline);
            }

            return InvokeAsync(StateHasChanged);
        });
    }

    private Task OnOutlineSelected(OutlineItem item)
    {
        return ExecuteSafeAsync("OnOutlineSelected", () =>
        {
            if (item is null || _disposed)
            {
                return Task.CompletedTask;
            }

            return InvokeCommandAsync("scrollToPosition", item.Position);
        });
    }

    private Task OnFormattingChanged(EditorFormattingState state)
    {
        return ExecuteSafeAsync("OnFormattingChanged", () =>
        {
            if (_disposed)
            {
                return Task.CompletedTask;
            }

            _formattingState = state ?? new EditorFormattingState();
            _fontFamily = _formattingState.FontFamily is null
                ? "mixed"
                : string.IsNullOrWhiteSpace(_formattingState.FontFamily) ? string.Empty : _formattingState.FontFamily;
            _fontSize = _formattingState.FontSize is null
                ? "mixed"
                : string.IsNullOrWhiteSpace(_formattingState.FontSize) ? "16" : _formattingState.FontSize;

            return InvokeAsync(StateHasChanged);
        });
    }

    private Task OnSelectionChanged(SectionEditor.EditorSelectionRange range)
    {
        return ExecuteSafeAsync("OnSelectionChanged", () =>
        {
            if (_disposed)
            {
                return Task.CompletedTask;
            }

            UpdateSelectionRange(range.Start, range.End);
            UpdateAiContextMenuState();
            return UpdateAiDecorationsAsync();
        });
    }

    private static string GetActiveClass(bool isActive) => isActive ? "is-active" : string.Empty;

    private string GetContextMenuStyle()
    {
        string left = _contextMenuX.ToString(CultureInfo.InvariantCulture);
        string top = _contextMenuY.ToString(CultureInfo.InvariantCulture);
        return $"left: {left}px; top: {top}px;";
    }

    private Task OnEditorContextMenuRequested(SectionEditor.EditorContextMenuRequest request)
    {
        return ExecuteSafeAsync("OnEditorContextMenuRequested", () =>
        {
            UpdateAiContextMenuState();
            _isContextMenuOpen = true;
            _contextMenuX = request.X;
            _contextMenuY = request.Y;
            _shouldFocusContextMenu = true;
            return InvokeAsync(StateHasChanged);
        });
    }

    private void CloseContextMenu()
    {
        _isContextMenuOpen = false;
    }

    private async Task OnContextMenuCommand(Func<Task> command)
    {
        CloseContextMenu();
        if (command is null)
        {
            return;
        }

        await command();
    }

    private Task OnRollbackAiEdit()
    {
        return ExecuteSafeAsync("OnRollbackAiEdit", () =>
        {
            if (_aiRollbackGroupId is null)
            {
                return Task.CompletedTask;
            }

            _commandProcessor.RollbackAiEditGroup(_activeSectionId, _aiRollbackGroupId.Value);
            return InvokeCommandAsync("focusEditor");
        });
    }

    private Task OnRollbackAllAiEdits()
    {
        return ExecuteSafeAsync("OnRollbackAllAiEdits", () =>
        {
            _commandProcessor.RollbackAllAiEdits(_activeSectionId);
            return InvokeCommandAsync("focusEditor");
        });
    }

    private Task OnRollbackAiHistoryEntry(AIHistoryEntry entry)
    {
        return ExecuteSafeAsync("OnRollbackAiHistoryEntry", async () =>
        {
            if (entry is null || _isAiHistoryRollback)
            {
                return;
            }

            if (!IsAiHistoryEntryActive(entry))
            {
                return;
            }

            bool confirmed = await JSRuntime.InvokeAsync<bool>("confirm", "Undo this AI change?");
            if (!confirmed)
            {
                return;
            }

            _isAiHistoryRollback = true;
            try
            {
                _commandProcessor.RollbackAiEditGroup(entry.AffectedSectionId, entry.EditGroupId);
            }
            finally
            {
                _isAiHistoryRollback = false;
            }
        });
    }

    private Task OnToggleAiHistoryDetails(AIHistoryEntry entry)
    {
        if (entry is null)
        {
            return Task.CompletedTask;
        }

        _aiHistoryDetailsId = _aiHistoryDetailsId == entry.EditGroupId ? null : entry.EditGroupId;
        return InvokeAsync(StateHasChanged);
    }

    private Task OnAiActionSelected(AiActionOption action)
    {
        return ExecuteSafeAsync("OnAiActionSelected", async () =>
        {
            if (!IsAiAvailable)
            {
                ShowAiMessage(GetAiBlockedMessage());
                await InvokeAsync(StateHasChanged);
                return;
            }

            if (_currentSelectionRange is null)
            {
                return;
            }

            if (!AiOrchestrator.CanRunAction(RewriteSelectionAction.ActionIdValue))
            {
                return;
            }

            string plainText = PlainTextMapper.ToPlainText(_activeSectionContent);
            if (plainText.Length == 0)
            {
                return;
            }

            CancelAiStream();

            TextRange normalized = NormalizeRange(_currentSelectionRange, plainText.Length);
            TextRange selectionRange = ResolveSelectionRange(action, normalized, plainText.Length);
            string originalText = ExtractRangeText(plainText, selectionRange);

            AiActionInput input = new(
                _state.Document,
                _activeSectionId,
                selectionRange,
                originalText,
                action.Instruction,
                action.Inputs);

            AiStreamingCapabilities streamingCapabilities = AiOrchestrator.GetStreamingCapabilities(RewriteSelectionAction.ActionIdValue);
            if (streamingCapabilities.SupportsTextStreaming)
            {
                bool started = await StartAiStreamingAsync(
                    RewriteSelectionAction.ActionIdValue,
                    input,
                    BuildActionLabel(action),
                    originalText);
                if (!started)
                {
                    await InvokeAsync(StateHasChanged);
                }

                return;
            }

            AiExecutionResult result;
            try
            {
                result = await AiOrchestrator.ExecuteActionAsync(
                    RewriteSelectionAction.ActionIdValue,
                    input,
                    CancellationToken.None);
            }
            catch (Exception ex)
            {
                ShowAiMessage(ex.Message);
                await InvokeAsync(StateHasChanged);
                return;
            }

            if (!result.Succeeded || result.Proposal is null)
            {
                ShowAiMessage(result.ErrorMessage ?? "AI is not available.");
                await InvokeAsync(StateHasChanged);
                return;
            }

            AiProposal proposal = result.Proposal;

            _pendingAiProposal = new PendingAiProposal(
                proposal,
                BuildActionLabel(action),
                originalText,
                GetProposedText(proposal),
                GetImageDataUrl(proposal),
                DateTime.UtcNow);
            _aiStreamError = null;

            await LoadAiUsageStatusAsync();
            await InvokeAsync(StateHasChanged);
        });
    }

    private Task OnGenerateCoverImage()
    {
        return ExecuteSafeAsync("OnGenerateCoverImage", async () =>
        {
            if (!IsAiAvailable)
            {
                ShowAiMessage(GetAiBlockedMessage());
                await InvokeAsync(StateHasChanged);
                return;
            }

            if (!AiOrchestrator.CanRunAction(GenerateCoverImageAction.ActionIdValue))
            {
                return;
            }

            CancelAiStream();

            string plainText = PlainTextMapper.ToPlainText(_activeSectionContent);
            TextRange selectionRange = new(0, Math.Max(0, plainText.Length));

            AiActionInput input = new(
                _state.Document,
                _activeSectionId,
                selectionRange,
                string.Empty,
                "Generate cover image",
                null);

            AiStreamingCapabilities streamingCapabilities = AiOrchestrator.GetStreamingCapabilities(GenerateCoverImageAction.ActionIdValue);
            if (streamingCapabilities.SupportsImageStreaming)
            {
                bool started = await StartAiStreamingAsync(
                    GenerateCoverImageAction.ActionIdValue,
                    input,
                    "Generate cover image",
                    string.Empty);
                if (!started)
                {
                    await InvokeAsync(StateHasChanged);
                }

                return;
            }

            AiExecutionResult result;
            try
            {
                result = await AiOrchestrator.ExecuteActionAsync(
                    GenerateCoverImageAction.ActionIdValue,
                    input,
                    CancellationToken.None);
            }
            catch (Exception ex)
            {
                ShowAiMessage(ex.Message);
                await InvokeAsync(StateHasChanged);
                return;
            }

            if (!result.Succeeded || result.Proposal is null)
            {
                ShowAiMessage(result.ErrorMessage ?? "AI is not available.");
                await InvokeAsync(StateHasChanged);
                return;
            }

            AiProposal proposal = result.Proposal;

            _pendingAiProposal = new PendingAiProposal(
                proposal,
                "Generate cover image",
                string.Empty,
                GetProposedText(proposal),
                GetImageDataUrl(proposal),
                DateTime.UtcNow);
            _aiStreamError = null;

            if (proposal.ArtifactIds.Count > 0)
            {
                AiAttachmentStore.SetCoverImageId(_activeSectionId, proposal.ArtifactIds[0]);
            }

            await LoadAiUsageStatusAsync();
            await InvokeAsync(StateHasChanged);
        });
    }

    private bool _canApplyPendingAiProposal => !_isAiStreaming && _pendingAiProposal?.Proposal is not null;

    private Task OnApplyPendingAiProposal()
    {
        return ExecuteSafeAsync("OnApplyPendingAiProposal", () =>
        {
            if (_pendingAiProposal is null)
            {
                return Task.CompletedTask;
            }

            PendingAiProposal pending = _pendingAiProposal;
            if (_isAiStreaming || pending.Proposal is null)
            {
                return Task.CompletedTask;
            }

            _pendingAiProposal = null;
            AiProposalApplier.Apply(_commandProcessor, pending.Proposal);
            AiAttachmentStore.SetCoverImageId(pending.Proposal.SectionId, null);

            return InvokeCommandAsync("focusEditor");
        });
    }

    private Task OnDiscardPendingAiProposal()
    {
        return ExecuteSafeAsync("OnDiscardPendingAiProposal", () =>
        {
            CancelAiStream();
            _pendingAiProposal = null;
            _aiStreamError = null;
            AiAttachmentStore.SetCoverImageId(_activeSectionId, null);
            return InvokeAsync(StateHasChanged);
        });
    }

    private async Task<bool> StartAiStreamingAsync(
        string actionId,
        AiActionInput input,
        string instructionLabel,
        string originalText)
    {
        CancelAiStream();

        CancellationTokenSource cts = new();
        _aiStreamCts = cts;
        _isAiStreaming = true;
        _aiStreamError = null;
        _streamedText = string.Empty;
        _streamedImageReference = null;

        // Preview updates stream into the panel; apply is only enabled after completion.
        _pendingAiProposal = new PendingAiProposal(
            null,
            instructionLabel,
            originalText,
            null,
            null,
            DateTime.UtcNow);

        await InvokeAsync(StateHasChanged);

        AiStreamingSession session = AiOrchestrator.StreamActionAsync(actionId, input, cts.Token);

        try
        {
            await foreach (AiStreamEvent streamEvent in session.Events.WithCancellation(cts.Token))
            {
                switch (streamEvent)
                {
                    case AiStreamEvent.TextDelta textDelta:
                        if (!string.IsNullOrEmpty(textDelta.Delta))
                        {
                            _streamedText += textDelta.Delta;
                            if (_pendingAiProposal is not null)
                            {
                                _pendingAiProposal = _pendingAiProposal with { ProposedText = _streamedText };
                            }
                        }

                        break;
                    case AiStreamEvent.ImageDelta imageDelta:
                        if (!string.IsNullOrWhiteSpace(imageDelta.Reference))
                        {
                            _streamedImageReference = imageDelta.Reference;
                            if (_pendingAiProposal is not null)
                            {
                                _pendingAiProposal = _pendingAiProposal with { ImageDataUrl = imageDelta.Reference };
                            }
                        }

                        break;
                    case AiStreamEvent.Failed failed:
                        _aiStreamError = failed.Error;
                        break;
                }

                await InvokeAsync(StateHasChanged);
            }
        }
        catch (OperationCanceledException)
        {
            return false;
        }
        finally
        {
            if (_aiStreamCts == cts)
            {
                _aiStreamCts = null;
                _isAiStreaming = false;
            }
        }

        if (cts.IsCancellationRequested)
        {
            return false;
        }

        AiProposal? proposal = await session.Completion;
        if (proposal is null)
        {
            await InvokeAsync(StateHasChanged);
            return false;
        }

        string? proposedText = GetProposedText(proposal);
        string? imageDataUrl = GetImageDataUrl(proposal);

        _pendingAiProposal = new PendingAiProposal(
            proposal,
            instructionLabel,
            originalText,
            proposedText,
            imageDataUrl,
            DateTime.UtcNow);

        if (proposal.ArtifactIds.Count > 0)
        {
            AiAttachmentStore.SetCoverImageId(_activeSectionId, proposal.ArtifactIds[0]);
        }

        await LoadAiUsageStatusAsync();
        await InvokeAsync(StateHasChanged);
        return true;
    }

    private bool CanShowAiMenu => _canShowAiMenu;

    private bool IsAiAvailable => IsAiUiEnabled && IsAiEntitled && !IsAiQuotaExceeded;

    private bool IsAiUiEnabled => _aiUsageStatus?.UiEnabled == true;

    private bool IsAiEntitled => _aiUsageStatus?.AiEnabled == true;

    private bool IsAiQuotaExceeded => _aiUsageStatus is not null && _aiUsageStatus.QuotaRemaining <= 0;

    private bool ShouldShowUpgradePrompt => IsAiUiEnabled && (_aiUsageStatus is null || !IsAiEntitled || IsAiQuotaExceeded);

    private string GetAiBlockedMessage()
    {
        if (_aiUsageStatus is null)
        {
            return "AI is not available right now.";
        }

        if (!IsAiEntitled)
        {
            return "AI is not enabled for your plan.";
        }

        if (IsAiQuotaExceeded)
        {
            return "You've reached your monthly AI limit.";
        }

        return "AI usage is not available.";
    }

    private async Task LoadAiUsageStatusAsync()
    {
        if (_disposed)
        {
            return;
        }

        if (_aiUsageRefreshInProgress)
        {
            return;
        }

        _aiUsageRefreshInProgress = true;
        try
        {
            try
            {
                AuthenticationState authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
                ClaimsPrincipal user = authState.User;
                string userId = UserIdResolver.ResolveUserId(user);

                AiUsageStatus status = await AiUsageStatusService.GetStatusAsync(userId);
                WriterAiOptions aiOptions = AiOptionsAccessor.Value;

                _aiUsageStatus = new AiUsageStatusDto
                {
                    Plan = status.PlanName,
                    AiEnabled = aiOptions.Enabled && status.AiEnabled,
                    UiEnabled = aiOptions.Enabled && aiOptions.UI.ShowAiMenu,
                    QuotaTotal = status.QuotaTotal,
                    QuotaRemaining = status.QuotaRemaining
                };

                Logger.LogInformation(
                    "AI status received: Plan={Plan}, AiEnabled={AiEnabled}, UiEnabled={UiEnabled}, QuotaRemaining={QuotaRemaining}, QuotaTotal={QuotaTotal}",
                    _aiUsageStatus.Plan,
                    _aiUsageStatus.AiEnabled,
                    _aiUsageStatus.UiEnabled,
                    _aiUsageStatus.QuotaRemaining,
                    _aiUsageStatus.QuotaTotal);
            }
            catch (SecurityException ex)
            {
                Logger.LogWarning(ex, "AI status resolution failed.");
                _aiUsageStatus = null;
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "AI status resolution failed.");
                _aiUsageStatus = null;
            }
            UpdateAiMenuVisibility();
            await InvokeAsync(StateHasChanged);
        }
        finally
        {
            _aiUsageRefreshInProgress = false;
        }
    }

    private void StartAiUsageRefreshLoop()
    {
        _aiUsageRefreshCts?.Cancel();
        _aiUsageRefreshCts?.Dispose();
        _aiUsageRefreshCts = new CancellationTokenSource();

        CancellationToken token = _aiUsageRefreshCts.Token;
        _aiUsageRefreshTask = Task.Run(async () =>
        {
            using PeriodicTimer timer = new(TimeSpan.FromSeconds(30));
            try
            {
                while (await timer.WaitForNextTickAsync(token))
                {
                    if (_disposed || token.IsCancellationRequested)
                    {
                        break;
                    }

                    await InvokeAsync(LoadAiUsageStatusAsync);
                }
            }
            catch (OperationCanceledException)
            {
            }
        }, token);
    }

    private void UpdateAiMenuVisibility()
    {
        bool aiEnabled = _aiUsageStatus?.AiEnabled == true;
        bool uiEnabled = _aiUsageStatus?.UiEnabled == true;
        bool visible = uiEnabled && aiEnabled;

        if (!aiEnabled)
        {
            Logger.LogDebug("AI menu hidden: feature flag disabled");
        }

        if (!uiEnabled)
        {
            Logger.LogDebug("AI menu hidden: UI flag disabled");
        }

        if (_lastAiMenuVisibility is null || _lastAiMenuVisibility.Value != visible)
        {
            Logger.LogInformation(
                "AI menu visibility: {Visible} (AIEnabled={AiEnabled}, UiEnabled={UiEnabled})",
                visible,
                aiEnabled,
                uiEnabled);
            _lastAiMenuVisibility = visible;
        }

        _canShowAiMenu = visible;
    }

    private void ShowAiMessage(string message)
    {
        CancelAiStream();
        _aiStreamError = message;
        _pendingAiProposal = new PendingAiProposal(
            null,
            "AI",
            string.Empty,
            null,
            null,
            DateTime.UtcNow);
    }

    private double GetAiUsagePercent()
    {
        if (_aiUsageStatus is null || _aiUsageStatus.QuotaTotal <= 0)
        {
            return 0;
        }

        long used = Math.Max(0, _aiUsageStatus.QuotaTotal - _aiUsageStatus.QuotaRemaining);
        return Math.Clamp(used / (double)_aiUsageStatus.QuotaTotal * 100d, 0d, 100d);
    }

    private async Task OnViewPlansAsync()
    {
        _showPlansPanel = true;
        _plansError = null;

        if (_planCatalog.Count > 0)
        {
            return;
        }

        _isPlansLoading = true;
        try
        {
            List<Plan> plans = await DbContext.Plans
                .Include(plan => plan.Entitlements)
                .Where(plan => plan.IsActive)
                .OrderBy(plan => plan.Name)
                .ToListAsync();

            _planCatalog.Clear();
            _planCatalog.AddRange(plans);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Plan catalog load failed.");
            _plansError = "Plans could not be loaded.";
        }
        finally
        {
            _isPlansLoading = false;
        }
    }

    private void ClosePlansPanel()
    {
        _showPlansPanel = false;
    }

    private static string GetEntitlementValue(Plan plan, string key)
    {
        if (plan.Entitlements is null)
        {
            return "Not available";
        }

        PlanEntitlement? entitlement = plan.Entitlements.FirstOrDefault(item => string.Equals(item.Key, key, StringComparison.OrdinalIgnoreCase));
        if (entitlement is null)
        {
            return "Not available";
        }

        return entitlement.Value;
    }

    private void CancelAiStream()
    {
        if (_aiStreamCts is null)
        {
            return;
        }

        _aiStreamCts.Cancel();
        _aiStreamCts.Dispose();
        _aiStreamCts = null;
        _isAiStreaming = false;
    }

    private static TextRange NormalizeRange(TextRange range, int sectionLength)
    {
        int start = Math.Clamp(range.Start, 0, sectionLength);
        int end = Math.Clamp(range.Start + range.Length, 0, sectionLength);
        if (end < start)
        {
            (start, end) = (end, start);
        }

        return new TextRange(start, Math.Max(0, end - start));
    }

    private static TextRange ResolveSelectionRange(AiActionOption action, TextRange selection, int sectionLength)
    {
        if (action.Scope == AiActionScope.Section)
        {
            return new TextRange(0, Math.Max(0, sectionLength));
        }

        if (selection.Length == 0)
        {
            return new TextRange(0, Math.Max(0, sectionLength));
        }

        return selection;
    }

    private static string ExtractRangeText(string plainText, TextRange range)
    {
        if (string.IsNullOrEmpty(plainText))
        {
            return string.Empty;
        }

        int start = Math.Clamp(range.Start, 0, plainText.Length);
        int end = Math.Clamp(range.Start + range.Length, 0, plainText.Length);
        if (end < start)
        {
            (start, end) = (end, start);
        }

        return plainText.Substring(start, Math.Max(0, end - start));
    }

    private static string? GetProposedText(AiProposal proposal)
    {
        for (int index = 0; index < proposal.Operations.Count; index++)
        {
            if (proposal.Operations[index] is ReplaceTextRangeOperation replaceOperation)
            {
                return replaceOperation.NewText;
            }
        }

        return null;
    }

    private static string BuildActionLabel(AiActionOption action)
    {
        string tone = GetInputValue(action.Inputs, "tone", "Neutral");
        string length = GetInputValue(action.Inputs, "length", "Same");
        bool preserveTerms = GetInputValue(action.Inputs, "preserve_terms", true);
        string preserveLabel = preserveTerms ? "Yes" : "No";
        return $"{action.Label}  Tone: {tone}  Length: {length}  Preserve terms: {preserveLabel}";
    }

    private static string GetInputValue(Dictionary<string, object?> inputs, string key, string defaultValue)
    {
        if (!inputs.TryGetValue(key, out object? value) || value is null)
        {
            return defaultValue;
        }

        return value.ToString() ?? defaultValue;
    }

    private static bool GetInputValue(Dictionary<string, object?> inputs, string key, bool defaultValue)
    {
        if (!inputs.TryGetValue(key, out object? value) || value is null)
        {
            return defaultValue;
        }

        if (value is bool boolValue)
        {
            return boolValue;
        }

        return bool.TryParse(value.ToString(), out bool parsed) ? parsed : defaultValue;
    }

    private string? GetImageDataUrl(AiProposal proposal)
    {
        for (int index = 0; index < proposal.ArtifactIds.Count; index++)
        {
            AiArtifact? artifact = ArtifactStore.Get(proposal.ArtifactIds[index]);
            if (artifact is null || artifact.Modality != AiModality.Image)
            {
                continue;
            }

            if (artifact.Metadata is not null && artifact.Metadata.TryGetValue("dataUrl", out object? value))
            {
                return value?.ToString();
            }

            if (artifact.BinaryContent is not null)
            {
                string base64 = Convert.ToBase64String(artifact.BinaryContent);
                return $"data:{artifact.MimeType};base64,{base64}";
            }
        }

        return null;
    }

    private string? GetCoverImageDataUrl(Guid sectionId)
    {
        Guid? previewId = _pendingAiProposal is not null ? AiAttachmentStore.GetCoverImageId(sectionId) : null;
        if (previewId is not null)
        {
            AiArtifact? previewArtifact = ArtifactStore.Get(previewId.Value);
            if (previewArtifact is not null)
            {
                if (previewArtifact.Metadata is not null && previewArtifact.Metadata.TryGetValue("dataUrl", out object? value))
                {
                    return value?.ToString();
                }

                if (previewArtifact.BinaryContent is not null)
                {
                    string base64 = Convert.ToBase64String(previewArtifact.BinaryContent);
                    return $"data:{previewArtifact.MimeType};base64,{base64}";
                }
            }
        }

        Guid? coverId = _state.Document.CoverImageId;
        if (coverId is null)
        {
            return null;
        }

        for (int index = 0; index < _state.Document.Artifacts.Count; index++)
        {
            DocumentArtifact artifact = _state.Document.Artifacts[index];
            if (artifact.ArtifactId != coverId.Value)
            {
                continue;
            }

            if (!string.IsNullOrWhiteSpace(artifact.DataUrl))
            {
                return artifact.DataUrl;
            }

            if (!string.IsNullOrWhiteSpace(artifact.Base64Data))
            {
                return $"data:{artifact.MimeType};base64,{artifact.Base64Data}";
            }
        }

        return null;
    }

    private void OnContextMenuKeyDown(KeyboardEventArgs args)
    {
        if (string.Equals(args.Key, "Escape", StringComparison.Ordinal))
        {
            CloseContextMenu();
        }
    }

    private Task HandleDocumentChangedAsync()
    {
        return ExecuteSafeAsync("HandleDocumentChangedAsync", async () =>
        {
            if (_disposed)
            {
                return;
            }

            RefreshFromDocument(_state.Document);
            if (_pendingAiProposal is not null)
            {
                _pendingAiProposal = null;
            }
            await UpdateAiDecorationsAsync();

            if (_suppressDirtyUpdate)
            {
                _suppressDirtyUpdate = false;
            }
            else
            {
                _isDirty = true;
            }

            bool shouldSyncEditor = !_skipNextEditorSync;
            _skipNextEditorSync = false;

            if (_editorRef is not null && shouldSyncEditor)
            {
                _suppressEditorEvent = true;
                try
                {
                    await _editorRef.SetContentAsync(_activeSectionContent);
                }
                finally
                {
                    _suppressEditorEvent = false;
                }
            }

            ScheduleAutosave();
            await InvokeAsync(StateHasChanged);
        });
    }

    private void RefreshFromDocument(Document document)
    {
        string title = GetDocumentTitle(document);
        HeaderState.DocumentTitle = title;
        _documentTitleDraft = title;
        _previewSections.Clear();
        _orderedSections.Clear();
        _sectionNumbering = _numberingService.BuildIndex(document);
        int wordCount = 0;
        for (int chapterIndex = 0; chapterIndex < document.Chapters.Count; chapterIndex++)
        {
            Chapter chapter = document.Chapters[chapterIndex];
            for (int sectionIndex = 0; sectionIndex < chapter.Sections.Count; sectionIndex++)
            {
                Section section = chapter.Sections[sectionIndex];
                _previewSections.Add(BuildPreviewSectionHtml(section));
                wordCount += CountWords(section.Content.Value);
            }
        }

        Chapter? primaryChapter = document.Chapters.Count > 0 ? document.Chapters[0] : null;
        if (primaryChapter is not null)
        {
            _orderedSections.AddRange(primaryChapter.Sections.OrderBy(section => section.Order));
        }

        Section activeSection = FindSection(document, _activeSectionId);
        _activeSectionContent = activeSection.Content.Value ?? string.Empty;
        UpdateReadingMetrics(wordCount);
    }

    private string BuildPreviewSectionHtml(Section section)
    {
        string title = GetSectionTitle(section);
        SectionNumberingInfo? info = _sectionNumbering.TryGetValue(section.SectionId, out SectionNumberingInfo entry)
            ? entry
            : null;
        string heading = _numberingService.BuildHeading(section, title, info);
        string normalizedContent = ExportHelpers.NormalizeSectionHtmlForExport(
            section.Content.Value ?? string.Empty,
            title).Trim();

        if (string.IsNullOrWhiteSpace(heading))
        {
            return normalizedContent;
        }

        string headingHtml = $"<h2>{WebUtility.HtmlEncode(heading)}</h2>";
        if (string.IsNullOrWhiteSpace(normalizedContent))
        {
            return headingHtml;
        }

        return $"{headingHtml}\n{normalizedContent}";
    }

    private static string GetDocumentTitle(Document document)
    {
        return string.IsNullOrWhiteSpace(document.Metadata.Title) ? "Untitled" : document.Metadata.Title;
    }

    private static int CountWords(string? html)
    {
        if (string.IsNullOrWhiteSpace(html))
        {
            return 0;
        }

        string decoded = ExtractPlainText(html);
        MatchCollection matches = Regex.Matches(decoded, @"\b[\p{L}\p{N}']+\b");
        return matches.Count;
    }

    private static int CountCharacters(string? html)
    {
        if (string.IsNullOrWhiteSpace(html))
        {
            return 0;
        }

        string decoded = ExtractPlainText(html);
        return decoded.Length;
    }

    private static string ExtractPlainText(string html)
    {
        return PlainTextMapper.ToPlainText(html);
    }

    private void UpdateSelectionRange(int start, int end)
    {
        if (start < 0 || end < 0)
        {
            _currentSelectionRange = null;
            return;
        }

        string plainText = PlainTextMapper.ToPlainText(_activeSectionContent);
        int maxLength = plainText.Length;
        int normalizedStart = Math.Clamp(Math.Min(start, end), 0, maxLength);
        int normalizedEnd = Math.Clamp(Math.Max(start, end), 0, maxLength);
        _currentSelectionRange = new TextRange(normalizedStart, normalizedEnd - normalizedStart);
    }

    private void UpdateAiContextMenuState()
    {
        _hasAiEditsAtSelection = false;
        _hasMultipleAiEditsInSection = false;
        _aiRollbackGroupId = null;

        if (_currentSelectionRange is null)
        {
            return;
        }

        string plainText = PlainTextMapper.ToPlainText(_activeSectionContent);
        AiEditSelectionInfo info = _commandProcessor.GetAiEditSelectionInfo(
            _activeSectionId,
            _currentSelectionRange,
            plainText.Length);

        _hasAiEditsAtSelection = info.HasIntersection;
        _hasMultipleAiEditsInSection = info.HasMultipleGroups;
        _aiRollbackGroupId = info.GroupId;
    }

    private async Task UpdateAiDecorationsAsync()
    {
        if (_editorInstance is null)
        {
            return;
        }

        string plainText = PlainTextMapper.ToPlainText(_activeSectionContent);
        IReadOnlyList<AiEditRangeInfo> ranges = _commandProcessor.GetAiEditRanges(_activeSectionId, plainText.Length);
        List<AiEditDecoration> decorations = new(ranges.Count);

        for (int index = 0; index < ranges.Count; index++)
        {
            TextRange range = ranges[index].Range;
            int start = Math.Clamp(range.Start, 0, plainText.Length);
            int end = Math.Clamp(range.Start + range.Length, 0, plainText.Length);
            if (end <= start)
            {
                continue;
            }

            bool isActive = _currentSelectionRange is not null
                && RangesIntersect(_currentSelectionRange, new TextRange(start, end - start));

            decorations.Add(new AiEditDecoration(start, end, isActive));
        }

        await JSRuntime.InvokeVoidAsync("tiptapEditor.setAiDecorations", _editorInstance, decorations);
    }

    private static bool RangesIntersect(TextRange selection, TextRange target)
    {
        if (selection.Length == 0)
        {
            int point = selection.Start;
            return point >= target.Start && point <= target.Start + target.Length;
        }

        int selectionEnd = selection.Start + selection.Length;
        int targetEnd = target.Start + target.Length;
        return selection.Start < targetEnd && target.Start < selectionEnd;
    }

    private void UpdateReadingMetrics(int wordCount)
    {
        _wordCount = wordCount;
        if (wordCount == 0)
        {
            _readingTime = "0 min read";
            return;
        }

        int minutes = Math.Max(1, (int)Math.Ceiling(wordCount / 220.0));
        _readingTime = $"{minutes} min read";
    }

    private IReadOnlyList<AIHistoryEntry> GetActiveSectionAiHistory()
    {
        if (_state?.Document is null || _activeSectionId == Guid.Empty)
        {
            return Array.Empty<AIHistoryEntry>();
        }

        Section section = FindSection(_state.Document, _activeSectionId);
        SectionAIInfo aiInfo = section.AI;
        if (aiInfo is null || aiInfo.AIHistory is null || aiInfo.AIHistory.Count == 0)
        {
            return Array.Empty<AIHistoryEntry>();
        }

        return aiInfo.AIHistory
            .OrderByDescending(entry => entry.TimestampUtc)
            .ToList();
    }

    private bool IsAiHistoryEntryActive(AIHistoryEntry entry)
    {
        if (_state?.Document is null || entry is null)
        {
            return false;
        }

        Section section = FindSection(_state.Document, _activeSectionId);
        SectionAIInfo aiInfo = section.AI;
        if (aiInfo is null || aiInfo.AiEditGroups is null || aiInfo.AiEditGroups.Count == 0)
        {
            return false;
        }

        return aiInfo.AiEditGroups.Exists(group => group.GroupId == entry.EditGroupId);
    }

    private string GetAiHistorySectionTitle(AIHistoryEntry entry)
    {
        if (_state?.Document is null)
        {
            return "Unknown section";
        }

        try
        {
            Section section = FindSection(_state.Document, entry.AffectedSectionId);
            return string.IsNullOrWhiteSpace(section.Title) ? "Untitled section" : section.Title;
        }
        catch (InvalidOperationException)
        {
            return "Unknown section";
        }
    }

    private static bool TryGetCharacterDelta(AIHistoryEntry entry, out int delta)
    {
        delta = 0;
        if (entry is null || entry.BeforeText is null || entry.AfterText is null)
        {
            return false;
        }

        delta = entry.AfterText.Length - entry.BeforeText.Length;
        return true;
    }

    private static string FormatDelta(int delta)
    {
        if (delta == 0)
        {
            return "0";
        }

        return delta > 0 ? $"+{delta}" : delta.ToString(CultureInfo.InvariantCulture);
    }

    private static string FormatHistoryText(string? text)
    {
        return text is null ? "No text captured." : text;
    }

    private static string FormatRelativeTime(DateTime timestampUtc)
    {
        DateTime utc = timestampUtc.Kind == DateTimeKind.Utc ? timestampUtc : timestampUtc.ToUniversalTime();
        TimeSpan delta = DateTime.UtcNow - utc;
        if (delta < TimeSpan.Zero)
        {
            delta = TimeSpan.Zero;
        }

        if (delta < TimeSpan.FromMinutes(1))
        {
            return "just now";
        }

        if (delta < TimeSpan.FromHours(1))
        {
            int minutes = Math.Max(1, (int)delta.TotalMinutes);
            return minutes == 1 ? "1 min ago" : $"{minutes} min ago";
        }

        if (delta < TimeSpan.FromDays(1))
        {
            int hours = Math.Max(1, (int)delta.TotalHours);
            return hours == 1 ? "1 hr ago" : $"{hours} hr ago";
        }

        int days = Math.Max(1, (int)delta.TotalDays);
        if (days < 7)
        {
            return days == 1 ? "1 day ago" : $"{days} days ago";
        }

        return utc.ToString("yyyy-MM-dd", CultureInfo.InvariantCulture);
    }

    private static Section FindSection(Document document, Guid sectionId)
    {
        for (int chapterIndex = 0; chapterIndex < document.Chapters.Count; chapterIndex++)
        {
            Chapter chapter = document.Chapters[chapterIndex];
            for (int sectionIndex = 0; sectionIndex < chapter.Sections.Count; sectionIndex++)
            {
                Section section = chapter.Sections[sectionIndex];
                if (section.SectionId == sectionId)
                {
                    return section;
                }
            }
        }

        throw new InvalidOperationException($"Section {sectionId} was not found.");
    }

    private Task OnEditorReady(IJSObjectReference editor)
    {
        return ExecuteSafeAsync("OnEditorReady", async () =>
        {
            _editorInstance = editor;
            await EnsureCommandsModuleAsync();
        });
    }

    private Task OnBoldRequested() => ExecuteSafeAsync("OnBoldRequested", () => InvokeCommandAsync("toggleBold"));

    private Task OnItalicRequested() => ExecuteSafeAsync("OnItalicRequested", () => InvokeCommandAsync("toggleItalic"));

    private Task OnStrikeRequested() => ExecuteSafeAsync("OnStrikeRequested", () => InvokeCommandAsync("toggleStrike"));

    private Task OnCodeRequested() => ExecuteSafeAsync("OnCodeRequested", () => InvokeCommandAsync("toggleCode"));

    private Task OnParagraphRequested() => ExecuteSafeAsync("OnParagraphRequested", () => InvokeCommandAsync("setParagraph"));

    private Task OnHeadingRequested(int level) => ExecuteSafeAsync("OnHeadingRequested", () => InvokeCommandAsync("toggleHeading", level));

    private Task OnBlockquoteRequested() => ExecuteSafeAsync("OnBlockquoteRequested", () => InvokeCommandAsync("toggleBlockquote"));

    private Task OnHorizontalRuleRequested() => ExecuteSafeAsync("OnHorizontalRuleRequested", () => InvokeCommandAsync("insertHorizontalRule"));

    private Task OnAlignRequested(string alignment)
        => ExecuteSafeAsync("OnAlignRequested", () => InvokeCommandAsync("setTextAlign", alignment));

    private Task OnIndentIncreaseRequested()
        => ExecuteSafeAsync("OnIndentIncreaseRequested", () => InvokeCommandAsync("increaseIndent"));

    private Task OnIndentDecreaseRequested()
        => ExecuteSafeAsync("OnIndentDecreaseRequested", () => InvokeCommandAsync("decreaseIndent"));

    private Task OnBulletListRequested() => ExecuteSafeAsync("OnBulletListRequested", () => InvokeCommandAsync("toggleBulletList"));

    private Task OnOrderedListRequested() => ExecuteSafeAsync("OnOrderedListRequested", () => InvokeCommandAsync("toggleOrderedList"));

    private async Task EnsureCommandsModuleAsync()
    {
        if (_commandsModule is null)
        {
            _commandsModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                "import",
                "/js/tiptap-commands.js");
        }
    }

    private async Task InvokeCommandAsync(string command, params object?[] extraArgs)
    {
        if (_editorInstance is null)
        {
            return;
        }

        await EnsureCommandsModuleAsync();
        if (_commandsModule is null)
        {
            return;
        }

        object?[] args = new object?[1 + extraArgs.Length];
        args[0] = _editorInstance;
        for (int i = 0; i < extraArgs.Length; i++)
        {
            args[i + 1] = extraArgs[i];
        }

        await _commandsModule.InvokeVoidAsync(command, args);

        if (!string.Equals(command, "focusEditor", StringComparison.Ordinal))
        {
            await _commandsModule.InvokeVoidAsync("focusEditor", _editorInstance);
        }
    }

    private Task OnSave()
    {
        return ExecuteSafeAsync("OnSave", async () =>
        {
            await SaveDocumentAsync();
        });
    }

    private async Task<Document?> SaveDocumentAsync()
    {
        if (_isManualSaveInProgress)
        {
            return null;
        }

        _isManualSaveInProgress = true;
        _autosaveCts?.Cancel();
        try
        {
            string? title = await EnsureDocumentTitleAsync();
            if (string.IsNullOrWhiteSpace(title))
            {
                return null;
            }

            Document withTitle = ApplyTitle(_state.Document, title);
            Document normalized = NormalizeDocumentForSave(withTitle);
            await DocumentStorage.SaveDocumentAsync(normalized);
            await DocumentStorage.ClearAutosaveAsync(normalized.DocumentId);
            _state.ReplaceDocument(normalized, notify: false);
            RefreshFromDocument(normalized);
            _lastSavedUtc = normalized.Metadata.ModifiedUtc;
            _isDirty = false;
            _autosaveStatus = AutosaveStatus.Idle;
            await InvokeAsync(StateHasChanged);
            return normalized;
        }
        finally
        {
            _isManualSaveInProgress = false;
        }
    }

    private void ToggleExportMenu()
    {
        _isExportMenuOpen = !_isExportMenuOpen;
    }

    private Task OnExportRequested(ExportKind kind, ExportFormat format)
    {
        return ExecuteSafeAsync("OnExportRequested", async () =>
        {
            _isExportMenuOpen = false;
            Document? saved = await SaveDocumentAsync();
            if (saved is null)
            {
                return;
            }

            ExportResult result = await ExportService.ExportAsync(saved, kind, format, new ExportOptions());
            await DownloadExportAsync(result);
        });
    }




    private Task OnExportPdfRequested()
    {
        return ExecuteSafeAsync("OnExportPdfRequested", async () =>
        {
            _isExportMenuOpen = false;
            Document? saved = await SaveDocumentAsync();
            if (saved is null)
            {
                return;
            }

            string bodyHtml = await ExportService.ExportHtmlBodyAsync(saved, ExportKind.Document, new ExportOptions());
            string printShell = BuildPrintShell(bodyHtml, saved.Metadata.Title);
            await PrintExportAsync(printShell);
        });
    }

    private static string BuildPrintShell(string bodyHtml, string title)
    {
        string safeTitle = System.Net.WebUtility.HtmlEncode(string.IsNullOrWhiteSpace(title) ? "Document" : title.Trim());
        string normalizedBody = ExportHelpers.NormalizeLineEndings(bodyHtml ?? string.Empty);

        return $"<!DOCTYPE html>\n<html>\n<head>\n  <title>{safeTitle}</title>\n  <link rel=\"stylesheet\" href=\"/css/print.css\">\n</head>\n<body class=\"print\">\n{normalizedBody}\n</body>\n</html>\n";
    }


    private async Task DownloadExportAsync(ExportResult result)
    {
        await EnsureExportModuleAsync();
        if (_exportModule is null)
        {
            return;
        }

        string payload = Convert.ToBase64String(result.Content);
        await _exportModule.InvokeVoidAsync("downloadFile", payload, result.MimeType, result.FileName);
    }




    private async Task PrintExportAsync(string html)
    {
        await EnsureExportModuleAsync();
        if (_exportModule is null)
        {
            return;
        }

        await _exportModule.InvokeVoidAsync("printHtmlAsPdf", html);
    }


    private async Task EnsureExportModuleAsync()
    {
        if (_exportModule is null)
        {
            _exportModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                "import",
                "/js/export.js");
        }
    }

    private async Task<string?> EnsureDocumentTitleAsync()
    {
        string title = _documentTitleDraft.Trim();
        if (!string.IsNullOrWhiteSpace(title))
        {
            return title;
        }

        string? response = null;
        try
        {
            response = await JSRuntime.InvokeAsync<string?>("prompt", "Name your document", string.Empty);
        }
        catch (JSException ex)
        {
            Logger.LogWarning(ex, "Document title prompt failed.");
        }

        if (string.IsNullOrWhiteSpace(response))
        {
            return null;
        }

        title = response.Trim();
        _documentTitleDraft = title;
        HeaderState.DocumentTitle = title;
        return title;
    }

    private static Document ApplyTitle(Document document, string title)
    {
        DocumentMetadata metadata = document.Metadata with { Title = title };
        return document with { Metadata = metadata };
    }

    private Task LoadDocumentFromRouteAsync(string? documentId)
    {
        return ExecuteSafeAsync("LoadDocumentFromRouteAsync", async () =>
        {
            if (string.IsNullOrWhiteSpace(documentId) || !Guid.TryParse(documentId, out _))
            {
                RedirectToLanding();
                return;
            }

            Document? document = await DocumentStorage.LoadDocumentByIdAsync(documentId);
            if (document is null)
            {
                RedirectToLanding();
                return;
            }

            InitializeState(NormalizeDocumentForLoad(document));
            _loadedDocumentId = documentId;
            await SyncEditorAsync();
            await CheckForRecoveryAsync(documentId, document);
        });
    }

    private void RedirectToLanding()
    {
        Navigation.NavigateTo("/", replace: true);
    }

    private async Task CheckForRecoveryAsync(string documentId, Document document)
    {
        DocumentStorageService.DocumentAutosave? autosave = await DocumentStorage.LoadAutosaveAsync(documentId);
        if (autosave is null || autosave.AutosavedUtc <= document.Metadata.ModifiedUtc)
        {
            _hasRecoveryCandidate = false;
            _recoveryCandidate = null;
            return;
        }

        _recoveryCandidate = autosave;
        _hasRecoveryCandidate = true;
        await InvokeAsync(StateHasChanged);
    }

    private Task OnAcceptRecovery()
    {
        return ExecuteSafeAsync("OnAcceptRecovery", async () =>
        {
            if (_recoveryCandidate is null)
            {
                return;
            }

            InitializeState(NormalizeDocumentForLoad(_recoveryCandidate.Document));
            _hasRecoveryCandidate = false;
            _lastAutosaveUtc = _recoveryCandidate.AutosavedUtc;
            _recoveryCandidate = null;
            _autosaveStatus = AutosaveStatus.Idle;
            _isDirty = true;
            await SyncEditorAsync();
            await InvokeAsync(StateHasChanged);
        });
    }

    private Task OnDiscardRecovery()
    {
        return ExecuteSafeAsync("OnDiscardRecovery", async () =>
        {
            if (_recoveryCandidate?.Document is null)
            {
                _hasRecoveryCandidate = false;
                return;
            }

            await DocumentStorage.ClearAutosaveAsync(_recoveryCandidate.Document.DocumentId);
            _hasRecoveryCandidate = false;
            _recoveryCandidate = null;
            _autosaveStatus = AutosaveStatus.Idle;
            await InvokeAsync(StateHasChanged);
        });
    }

    private Document BuildAutosaveDocument(Document document)
    {
        string title = string.IsNullOrWhiteSpace(_documentTitleDraft)
            ? document.Metadata.Title
            : _documentTitleDraft.Trim();

        Document normalized = NormalizeDocumentForLoad(document);
        DocumentMetadata updatedMetadata = normalized.Metadata with
        {
            Title = string.IsNullOrWhiteSpace(title) ? normalized.Metadata.Title : title,
            ModifiedUtc = DateTime.UtcNow
        };

        return normalized with { Metadata = updatedMetadata };
    }

    private void ScheduleAutosave()
    {
        if (_isManualSaveInProgress || _hasRecoveryCandidate || _loadedDocumentId is null)
        {
            return;
        }

        _autosaveCts?.Cancel();
        _autosaveCts?.Dispose();
        _autosaveCts = null;

        CancellationTokenSource cts = new();
        _autosaveCts = cts;
        _ = DebouncedAutosaveAsync(cts);
    }

    private async Task DebouncedAutosaveAsync(CancellationTokenSource cts)
    {
        try
        {
            await Task.Delay(AutosaveDebounce, cts.Token);
        }
        catch (TaskCanceledException)
        {
            return;
        }

        if (cts.IsCancellationRequested)
        {
            return;
        }

        await AutosaveAsync();
    }

    private async Task AutosaveAsync()
    {
        if (_isManualSaveInProgress || _hasRecoveryCandidate || _loadedDocumentId is null)
        {
            return;
        }

        _autosaveStatus = AutosaveStatus.Saving;
        await InvokeAsync(StateHasChanged);

        Document autosaveDocument = BuildAutosaveDocument(_state.Document);
        bool saved = await DocumentStorage.SaveAutosaveAsync(autosaveDocument.DocumentId, autosaveDocument, DateTime.UtcNow);
        if (saved)
        {
            _autosaveStatus = AutosaveStatus.Idle;
            _lastAutosaveUtc = DateTime.UtcNow;
            _isDirty = false;
        }
        else
        {
            _autosaveStatus = AutosaveStatus.Failed;
        }

        await InvokeAsync(StateHasChanged);
    }


    private Document NormalizeDocumentForSave(Document document)
    {
        Document normalized = NormalizeDocumentForLoad(document);
        DocumentMetadata updatedMetadata = normalized.Metadata with { ModifiedUtc = DateTime.UtcNow };
        return normalized with { Metadata = updatedMetadata };
    }

    private Document NormalizeDocumentForLoad(Document document)
    {
        document = DocumentFactory.EnsureSynopsis(document);
        string? title = document.Metadata.Title;
        if (string.IsNullOrWhiteSpace(title))
        {
            title = DeriveTitleFromDocument(document);
        }

        DocumentMetadata updatedMetadata = document.Metadata with
        {
            Title = title ?? document.Metadata.Title
        };

        List<Chapter> chapters = new();
        for (int chapterIndex = 0; chapterIndex < document.Chapters.Count; chapterIndex++)
        {
            Chapter chapter = document.Chapters[chapterIndex];
            List<Section> sections = new();
            for (int sectionIndex = 0; sectionIndex < chapter.Sections.Count; sectionIndex++)
            {
                Section section = chapter.Sections[sectionIndex];
                SectionStats stats = new()
                {
                    WordCount = CountWords(section.Content.Value),
                    CharacterCount = CountCharacters(section.Content.Value)
                };

                sections.Add(section with { Stats = stats });
            }

            chapters.Add(chapter with { Sections = sections });
        }

        return document with
        {
            Metadata = updatedMetadata,
            Chapters = chapters
        };
    }

    private static string? DeriveTitleFromDocument(Document document)
    {
        Regex headingRegex = new("<h[1-6][^>]*>(.*?)</h[1-6]>", RegexOptions.IgnoreCase | RegexOptions.Singleline);
        for (int chapterIndex = 0; chapterIndex < document.Chapters.Count; chapterIndex++)
        {
            Chapter chapter = document.Chapters[chapterIndex];
            for (int sectionIndex = 0; sectionIndex < chapter.Sections.Count; sectionIndex++)
            {
                Section section = chapter.Sections[sectionIndex];
                string html = section.Content.Value ?? string.Empty;
                Match match = headingRegex.Match(html);
                if (!match.Success)
                {
                    continue;
                }

                string plain = ExtractPlainText(match.Groups[1].Value);
                if (string.IsNullOrWhiteSpace(plain))
                {
                    continue;
                }

                plain = Regex.Replace(plain, @"\s+", " ").Trim();
                if (plain.Length > 60)
                {
                    plain = plain.Substring(0, 60).Trim();
                }

                return plain;
            }
        }

        return null;
    }

    private void InitializeState(Document document)
    {
        _state.OnChanged -= _onChangedHandler;
        _state = new DocumentState(document);
        _commandProcessor = new CommandProcessor(_state);
        _state.OnChanged += _onChangedHandler;
        HeaderState.DocumentId = _state.Document.DocumentId.ToString();

        if (document.Chapters.Count > 0 && document.Chapters[0].Sections.Count > 0)
        {
            _activeSectionId = document.Chapters[0].Sections[0].SectionId;
        }

        RefreshFromDocument(_state.Document);
        _lastSavedUtc = _state.Document.Metadata.ModifiedUtc;
        _isDirty = false;
    }

    private async Task SyncEditorAsync()
    {
        if (_editorRef is null)
        {
            return;
        }

        _suppressEditorEvent = true;
        try
        {
            await _editorRef.SetContentAsync(_activeSectionContent);
        }
        finally
        {
            _suppressEditorEvent = false;
        }
    }

    private string GetSaveStatusLabel()
    {
        return _autosaveStatus switch
        {
            AutosaveStatus.Saving => "Saving...",
            AutosaveStatus.Failed => "Autosave failed",
            _ when _isDirty => "Unsaved changes",
            _ => "All changes saved"
        };
    }

    private string GetSaveStatusClass()
    {
        return _autosaveStatus switch
        {
            AutosaveStatus.Saving => "saving-indicator",
            AutosaveStatus.Failed => "dirty-indicator",
            _ when _isDirty => "dirty-indicator",
            _ => "clean-indicator"
        };
    }

    private string GetLastSavedLabel()
    {
        if (_lastSavedUtc == default)
        {
            return "Not saved yet";
        }

        TimeSpan delta = DateTime.UtcNow - _lastSavedUtc;
        if (delta < TimeSpan.FromMinutes(1))
        {
            return "Last saved just now";
        }

        if (delta < TimeSpan.FromHours(1))
        {
            int minutes = Math.Max(1, (int)Math.Round(delta.TotalMinutes));
            return $"Last saved {minutes} min ago";
        }

        if (delta < TimeSpan.FromDays(1))
        {
            int hours = Math.Max(1, (int)Math.Round(delta.TotalHours));
            return $"Last saved {hours} hr ago";
        }

        int days = Math.Max(1, (int)Math.Round(delta.TotalDays));
        return $"Last saved {days} day{(days == 1 ? string.Empty : "s")} ago";
    }

    private async Task ExecuteSafeAsync(string operation, Func<Task> action)
    {
        try
        {
            await action();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Home {Operation} failed.", operation);
        }
    }

    private void ExecuteSafe(string operation, Action action)
    {
        try
        {
            action();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Home {Operation} failed.", operation);
        }
    }

    public void Dispose()
    {
        _state.OnChanged -= _onChangedHandler;
        _aiUsageRefreshCts?.Cancel();
        _aiUsageRefreshCts?.Dispose();
        _aiUsageRefreshCts = null;
        CancelAiStream();
        HeaderState.DocumentTitle = null;
        HeaderState.DocumentId = null;
        _autosaveCts?.Cancel();
        _autosaveCts?.Dispose();
        _autosaveCts = null;
    }

    public async ValueTask DisposeAsync()
    {
        if (_disposed)
        {
            return;
        }

        _disposed = true;
        _aiUsageRefreshCts?.Cancel();
        _aiUsageRefreshCts?.Dispose();
        _aiUsageRefreshCts = null;
        if (_aiUsageRefreshTask is not null)
        {
            try
            {
                await _aiUsageRefreshTask;
            }
            catch (OperationCanceledException)
            {
            }
        }

        if (_commandsModule is not null)
        {
            try
            {
                await _commandsModule.DisposeAsync();
            }
            catch (ObjectDisposedException)
            {
            }
            catch (JSDisconnectedException)
            {
            }
            finally
            {
                _commandsModule = null;
            }
        }

        if (_exportModule is not null)
        {
            try
            {
                await _exportModule.DisposeAsync();
            }
            catch (ObjectDisposedException)
            {
            }
            catch (JSDisconnectedException)
            {
            }
            finally
            {
                _exportModule = null;
            }
        }
    }

    private sealed record AiEditDecoration(int Start, int End, bool IsActive);

    private sealed record AiActionOption(
        string Label,
        string Instruction,
        AiActionScope Scope,
        Dictionary<string, object?> Inputs);
}
