@page "/"
@rendermode Microsoft.AspNetCore.Components.Web.RenderMode.InteractiveServer
@using System
@using System.Collections.Generic
@using System.Globalization
@using BlazorApp.Components.Editor
@using Microsoft.AspNetCore.Components
@using Microsoft.JSInterop
@using WriterApp.Application.Commands
@using WriterApp.Application.State
@using WriterApp.Domain.Documents
@implements IDisposable
@implements IAsyncDisposable
@inject IJSRuntime JSRuntime

<PageTitle>Writer</PageTitle>

<div class="editor-preview-layout">
    <div class="editor-pane">
        <div class="pane-header">
            <h2>Section Editor</h2>
            <div class="editor-toolbar" role="toolbar" aria-label="Editor formatting">
                <div class="editor-toolbar-group" aria-label="Text emphasis">
                    <button type="button" class="@GetActiveClass(_formattingState.IsBold)" disabled="@(!_formattingState.CanBold)" @onclick="OnBoldRequested">Bold</button>
                    <button type="button" class="@GetActiveClass(_formattingState.IsItalic)" disabled="@(!_formattingState.CanItalic)" @onclick="OnItalicRequested">Italic</button>
                    <button type="button" class="@GetActiveClass(_formattingState.IsStrike)" disabled="@(!_formattingState.CanStrike)" @onclick="OnStrikeRequested">Strike</button>
                    <button type="button" class="@GetActiveClass(_formattingState.IsCode)" disabled="@(!_formattingState.CanCode)" @onclick="OnCodeRequested">Code</button>
                </div>
                <div class="editor-toolbar-group" aria-label="Structure">
                    <button type="button" class="@GetActiveClass(_formattingState.BlockType == "paragraph")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="OnParagraphRequested">Paragraph</button>
                    <button type="button" class="@GetActiveClass(_formattingState.BlockType == "heading:1")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="() => OnHeadingRequested(1)">H1</button>
                    <button type="button" class="@GetActiveClass(_formattingState.BlockType == "heading:2")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="() => OnHeadingRequested(2)">H2</button>
                    <button type="button" class="@GetActiveClass(_formattingState.BlockType == "heading:3")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="() => OnHeadingRequested(3)">H3</button>
                    <button type="button" class="@GetActiveClass(_formattingState.BlockType == "heading:4")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="() => OnHeadingRequested(4)">H4</button>
                    <button type="button" class="@GetActiveClass(_formattingState.BlockType == "heading:5")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="() => OnHeadingRequested(5)">H5</button>
                    <button type="button" class="@GetActiveClass(_formattingState.BlockType == "heading:6")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="() => OnHeadingRequested(6)">H6</button>
                    <button type="button" disabled="@(!_formattingState.CanBlockquote)" @onclick="OnBlockquoteRequested">Blockquote</button>
                    <button type="button" disabled="@(!_formattingState.CanHorizontalRule)" @onclick="OnHorizontalRuleRequested">Horizontal rule</button>
                </div>
                <div class="editor-toolbar-group" aria-label="Lists">
                    <button type="button" disabled="@(!_formattingState.CanToggleList)" @onclick="OnBulletListRequested">Bullet list</button>
                    <button type="button" disabled="@(!_formattingState.CanToggleList)" @onclick="OnOrderedListRequested">Ordered list</button>
                </div>
                <div class="editor-toolbar-group" aria-label="Typography">
                    <label class="editor-toolbar-label" for="fontFamilySelect">Font</label>
                    <select id="fontFamilySelect" class="editor-toolbar-select" value="@_fontFamily" @onchange="OnFontFamilyChanged">
                        <option value="mixed" disabled>Mixed</option>
                        <option value="">Default</option>
                        <option value="Georgia">Georgia</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Arial">Arial</option>
                        <option value="Helvetica">Helvetica</option>
                        <option value="Courier New">Courier New</option>
                    </select>
                    <label class="editor-toolbar-label" for="fontSizeSelect">Text size</label>
                    <select id="fontSizeSelect" class="editor-toolbar-select" value="@_fontSize" @onchange="OnFontSizeChanged">
                        <option value="mixed" disabled>Mixed</option>
                        <option value="12">12px</option>
                        <option value="14">14px</option>
                        <option value="16">16px</option>
                        <option value="18">18px</option>
                        <option value="24">24px</option>
                        <option value="32">32px</option>
                    </select>
                </div>
            </div>
            <div class="editor-actions">
                <button type="button" @onclick="OnUndo" disabled="@(!_commandProcessor.CanUndo)">Undo</button>
                <button type="button" @onclick="OnRedo" disabled="@(!_commandProcessor.CanRedo)">Redo</button>
            </div>
        </div>
        <div class="pane-body editor-scroll">
            <SectionEditor @ref="_editorRef"
                           Content="@_activeSectionContent"
                           ContentChanged="OnSectionContentChanged"
                           EditorReady="OnEditorReady"
                           FormattingChanged="OnFormattingChanged"
                           UndoRequested="OnUndo"
                           RedoRequested="OnRedo" />
        </div>
    </div>
    <div class="preview-pane">
        <div class="pane-header">
            <h2>Document Preview</h2>
        </div>
        <div class="pane-body preview-scroll">
            <div class="document-preview">
                @if (_previewSections is not null)
                {
                    for (int i = 0; i < _previewSections.Count; i++)
                    {
                        string html = _previewSections[i] ?? string.Empty;
                        <section class="document-section">
                            @((MarkupString)html)
                        </section>
                    }
                }
            </div>
        </div>
    </div>
</div>

<style>
    .editor-preview-layout {
        display: flex;
        gap: 32px;
        align-items: flex-start;
        padding: 24px;
    }

    .editor-pane,
    .preview-pane {
        flex: 1 1 0;
        min-width: 320px;
    }

    .editor-pane h2,
    .preview-pane h2 {
        margin-top: 0;
        font-size: 1.1rem;
        letter-spacing: 0.02em;
    }

    .pane-header {
        display: flex;
        flex-direction: column;
        gap: 12px;
        padding-bottom: 12px;
        border-bottom: 1px solid #ececec;
        position: sticky;
        top: 0;
        background: #fff;
        z-index: 2;
    }

    .pane-header h2 {
        margin: 0;
    }

    .pane-body {
        padding-top: 12px;
        max-height: 70vh;
        overflow: auto;
    }

    .editor-toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
    }

    .editor-toolbar-group {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        padding-right: 10px;
        border-right: 1px solid #e3e3e3;
    }

    .editor-toolbar-group:last-child {
        padding-right: 0;
        border-right: none;
    }

    .editor-toolbar-label {
        align-self: center;
        font-size: 0.9rem;
    }

    .editor-toolbar-select {
        padding: 6px 8px;
        border: 1px solid #d0d0d0;
        border-radius: 4px;
        background: #fff;
        cursor: pointer;
    }

    .editor-actions {
        display: flex;
        gap: 8px;
        margin: 0;
    }

    .editor-actions button,
    .editor-toolbar button {
        padding: 6px 12px;
        border: 1px solid #d0d0d0;
        border-radius: 4px;
        background: #f8f8f8;
        cursor: pointer;
    }

    .editor-actions button:active,
    .editor-toolbar button:active {
        transform: translateY(1px);
    }

    .editor-toolbar button.is-active {
        background: #e6eefc;
        border-color: #9bb6f0;
    }

    .editor-toolbar button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .editor-pane .ProseMirror {
        min-height: 320px;
        padding: 12px;
        border: 1px solid #d9d9d9;
        border-radius: 6px;
        background: #fff;
    }

    .document-preview {
        max-width: 760px;
        margin: 0 auto;
        padding: 24px 28px;
        line-height: 1.6;
        font-family: "Georgia", "Times New Roman", serif;
        background: #fff;
        color: #1e1e1e;
        border: 1px solid #e2e2e2;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.06);
    }

    .document-section {
        margin-bottom: 28px;
        padding-bottom: 8px;
        border-bottom: 1px solid #f0f0f0;
    }

    .document-section:last-child {
        border-bottom: none;
        margin-bottom: 0;
        padding-bottom: 0;
    }

    @@media (max-width: 900px) {
        .editor-preview-layout {
            flex-direction: column;
        }

        .pane-body {
            max-height: none;
        }
    }
</style>

@code {
    private readonly DocumentState _state;
    private readonly CommandProcessor _commandProcessor;
    private readonly Action _onChangedHandler;
    private readonly List<string> _previewSections = new();
    private SectionEditor? _editorRef;
    private Guid _activeSectionId;
    private string _activeSectionContent = string.Empty;
    private bool _suppressEditorEvent;
    private bool _skipNextEditorSync;
    private IJSObjectReference? _editorInstance;
    private IJSObjectReference? _commandsModule;
    private string _fontSize = "16";
    private string _fontFamily = string.Empty;
    private EditorFormattingState _formattingState = new()
    {
        CanBold = true,
        CanItalic = true,
        CanStrike = true,
        CanCode = true,
        CanApplyHeading = true,
        CanToggleList = true,
        CanBlockquote = true,
        CanHorizontalRule = true
    };

    public Home()
    {
        Document document = CreateSampleDocument();
        _state = new DocumentState(document);
        _commandProcessor = new CommandProcessor(_state);
        _onChangedHandler = () => _ = HandleDocumentChangedAsync();
        _state.OnChanged += _onChangedHandler;

        if (document.Chapters.Count > 0 && document.Chapters[0].Sections.Count > 0)
        {
            _activeSectionId = document.Chapters[0].Sections[0].SectionId;
        }
    }

    protected override void OnInitialized()
    {
        RefreshFromDocument(_state.Document);
    }

    private Task OnSectionContentChanged(string html)
    {
        if (_suppressEditorEvent)
        {
            return Task.CompletedTask;
        }

        string content = html ?? string.Empty;
        Section section = FindSection(_state.Document, _activeSectionId);
        if (string.Equals(section.Content.Value, content, StringComparison.Ordinal))
        {
            return Task.CompletedTask;
        }

        _skipNextEditorSync = true;
        _commandProcessor.Execute(new UpdateSectionContentCommand(_activeSectionId, content));
        return Task.CompletedTask;
    }

    private Task OnUndo()
    {
        if (_commandProcessor.CanUndo)
        {
            _commandProcessor.Undo();
            return InvokeCommandAsync("focusEditor");
        }

        return Task.CompletedTask;
    }

    private Task OnRedo()
    {
        if (_commandProcessor.CanRedo)
        {
            _commandProcessor.Redo();
            return InvokeCommandAsync("focusEditor");
        }

        return Task.CompletedTask;
    }

    private async Task OnFontSizeChanged(ChangeEventArgs args)
    {
        if (args.Value is null)
        {
            return;
        }

        string? value = args.Value.ToString();
        if (string.Equals(value, "mixed", StringComparison.Ordinal))
        {
            return;
        }

        if (int.TryParse(value, out int size))
        {
            _fontSize = size.ToString(CultureInfo.InvariantCulture);
            await InvokeCommandAsync("setFontSize", size);
        }
    }

    private async Task OnFontFamilyChanged(ChangeEventArgs args)
    {
        string? family = args.Value?.ToString();
        _fontFamily = family ?? string.Empty;

        if (string.Equals(_fontFamily, "mixed", StringComparison.Ordinal))
        {
            return;
        }

        if (string.IsNullOrWhiteSpace(_fontFamily))
        {
            await InvokeCommandAsync("clearFontFamily");
            return;
        }

        await InvokeCommandAsync("setFontFamily", _fontFamily);
    }

    private Task OnFormattingChanged(EditorFormattingState state)
    {
        _formattingState = state ?? new EditorFormattingState();
        _fontFamily = _formattingState.FontFamily is null
            ? "mixed"
            : string.IsNullOrWhiteSpace(_formattingState.FontFamily) ? string.Empty : _formattingState.FontFamily;
        _fontSize = _formattingState.FontSize is null
            ? "mixed"
            : string.IsNullOrWhiteSpace(_formattingState.FontSize) ? "16" : _formattingState.FontSize;

        return InvokeAsync(StateHasChanged);
    }

    private static string GetActiveClass(bool isActive) => isActive ? "is-active" : string.Empty;

    private async Task HandleDocumentChangedAsync()
    {
        RefreshFromDocument(_state.Document);

        bool shouldSyncEditor = !_skipNextEditorSync;
        _skipNextEditorSync = false;

        if (_editorRef is not null && shouldSyncEditor)
        {
            _suppressEditorEvent = true;
            try
            {
                await _editorRef.SetContentAsync(_activeSectionContent);
            }
            finally
            {
                _suppressEditorEvent = false;
            }
        }

        await InvokeAsync(StateHasChanged);
    }

    private void RefreshFromDocument(Document document)
    {
        _previewSections.Clear();
        for (int chapterIndex = 0; chapterIndex < document.Chapters.Count; chapterIndex++)
        {
            Chapter chapter = document.Chapters[chapterIndex];
            for (int sectionIndex = 0; sectionIndex < chapter.Sections.Count; sectionIndex++)
            {
                Section section = chapter.Sections[sectionIndex];
                _previewSections.Add(section.Content.Value ?? string.Empty);
            }
        }

        Section activeSection = FindSection(document, _activeSectionId);
        _activeSectionContent = activeSection.Content.Value ?? string.Empty;
    }

    private static Section FindSection(Document document, Guid sectionId)
    {
        for (int chapterIndex = 0; chapterIndex < document.Chapters.Count; chapterIndex++)
        {
            Chapter chapter = document.Chapters[chapterIndex];
            for (int sectionIndex = 0; sectionIndex < chapter.Sections.Count; sectionIndex++)
            {
                Section section = chapter.Sections[sectionIndex];
                if (section.SectionId == sectionId)
                {
                    return section;
                }
            }
        }

        throw new InvalidOperationException($"Section {sectionId} was not found.");
    }

    private static Document CreateSampleDocument()
    {
        DateTime now = DateTime.UtcNow;

        return new Document
        {
            Metadata = new DocumentMetadata
            {
                Title = "Sample Draft",
                Author = "Demo",
                Language = "en",
                Tags = new List<string> { "demo" },
                CreatedUtc = now,
                ModifiedUtc = now
            },
            Settings = new DocumentSettings
            {
                DefaultFont = "Georgia",
                DefaultFontSize = 12,
                PageSize = "Letter",
                LineSpacing = 1.5
            },
            Chapters = new List<Chapter>
            {
                new Chapter
                {
                    Order = 0,
                    Title = "Draft",
                    Sections = new List<Section>
                    {
                        new Section
                        {
                            Order = 0,
                            Title = "Opening Scene",
                            Content = new SectionContent
                            {
                                Format = "html",
                                Value = "<h1>Opening Scene</h1><p>The storm rolled in just after dusk, wrapping the town in a soft gray hush.</p>"
                            },
                            Stats = new SectionStats(),
                            Flags = new SectionFlags(),
                            AI = new SectionAIInfo(),
                            CreatedUtc = now,
                            ModifiedUtc = now
                        },
                        new Section
                        {
                            Order = 1,
                            Title = "Chapter One",
                            Content = new SectionContent
                            {
                                Format = "html",
                                Value = "<h2>Chapter One</h2><p>Eva traced the map with her finger, pausing at the edge of the inked coastline.</p>"
                            },
                            Stats = new SectionStats(),
                            Flags = new SectionFlags(),
                            AI = new SectionAIInfo(),
                            CreatedUtc = now,
                            ModifiedUtc = now
                        },
                        new Section
                        {
                            Order = 2,
                            Title = "Chapter Two",
                            Content = new SectionContent
                            {
                                Format = "html",
                                Value = "<h2>Chapter Two</h2><p>By morning, the docks were empty, save for a single lantern swaying against the tide.</p>"
                            },
                            Stats = new SectionStats(),
                            Flags = new SectionFlags(),
                            AI = new SectionAIInfo(),
                            CreatedUtc = now,
                            ModifiedUtc = now
                        }
                    }
                }
            }
        };
    }

    private async Task OnEditorReady(IJSObjectReference editor)
    {
        _editorInstance = editor;
        await EnsureCommandsModuleAsync();
    }

    private Task OnBoldRequested() => InvokeCommandAsync("toggleBold");

    private Task OnItalicRequested() => InvokeCommandAsync("toggleItalic");

    private Task OnStrikeRequested() => InvokeCommandAsync("toggleStrike");

    private Task OnCodeRequested() => InvokeCommandAsync("toggleCode");

    private Task OnParagraphRequested() => InvokeCommandAsync("setParagraph");

    private Task OnHeadingRequested(int level) => InvokeCommandAsync("toggleHeading", level);

    private Task OnBlockquoteRequested() => InvokeCommandAsync("toggleBlockquote");

    private Task OnHorizontalRuleRequested() => InvokeCommandAsync("insertHorizontalRule");

    private Task OnBulletListRequested() => InvokeCommandAsync("toggleBulletList");

    private Task OnOrderedListRequested() => InvokeCommandAsync("toggleOrderedList");

    private async Task EnsureCommandsModuleAsync()
    {
        if (_commandsModule is null)
        {
            _commandsModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                "import",
                "/js/tiptap-commands.js");
        }
    }

    private async Task InvokeCommandAsync(string command, params object?[] extraArgs)
    {
        if (_editorInstance is null)
        {
            return;
        }

        await EnsureCommandsModuleAsync();
        if (_commandsModule is null)
        {
            return;
        }

        object?[] args = new object?[1 + extraArgs.Length];
        args[0] = _editorInstance;
        for (int i = 0; i < extraArgs.Length; i++)
        {
            args[i + 1] = extraArgs[i];
        }

        await _commandsModule.InvokeVoidAsync(command, args);

        if (!string.Equals(command, "focusEditor", StringComparison.Ordinal))
        {
            await _commandsModule.InvokeVoidAsync("focusEditor", _editorInstance);
        }
    }

    public void Dispose()
    {
        _state.OnChanged -= _onChangedHandler;
    }

    public async ValueTask DisposeAsync()
    {
        if (_commandsModule is not null)
        {
            try
            {
                await _commandsModule.DisposeAsync();
            }
            catch (ObjectDisposedException)
            {
            }
        }
    }
}
