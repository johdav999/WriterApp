@page "/"
@rendermode Microsoft.AspNetCore.Components.Web.RenderMode.InteractiveServer
@using System
@using System.Collections.Generic
@using System.Globalization
@using System.Linq
@using System.Runtime.CompilerServices
@using System.Text.Json
@using System.Text.RegularExpressions
@using System.Threading
@using BlazorApp.Components.Editor
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.Extensions.Hosting
@using Microsoft.Extensions.Logging
@using Microsoft.Extensions.Options
@using Microsoft.JSInterop
@using WriterApp.AI.Abstractions
@using WriterApp.AI.Actions
@using WriterApp.Application.Commands
@using WriterApp.Application.State
@using WriterApp.Domain.Documents
@implements IDisposable
@implements IAsyncDisposable
@inject IJSRuntime JSRuntime
@inject ILogger<Home> Logger
@inject IWebHostEnvironment HostEnvironment
@inject IAiOrchestrator AiOrchestrator
@inject IAiProposalApplier AiProposalApplier
@inject IArtifactStore ArtifactStore
@inject IAiAttachmentStore AiAttachmentStore
@inject IOptions<WriterAiOptions> AiOptions

<PageTitle>Writer</PageTitle>

<div class="editor-preview-layout">
    <div class="editor-pane">
        <div class="pane-header">
            <h2>Section Editor</h2>
            <div class="section-nav">
                <div class="section-nav-header">
                    <h3>Sections</h3>
                    <button type="button" @onclick="OnCreateSection">Add section</button>
                </div>
                <ul class="section-nav-list">
                    @foreach (Section section in _orderedSections)
                    {
                        <li class="drop-zone @(GetDropZoneClass(section.SectionId, DropPosition.Before))" @ondragover="OnDragOver" @ondragover:preventDefault @ondragenter="() => OnDragEnter(section.SectionId, DropPosition.Before)" @ondrop="() => OnDrop(section.SectionId, DropPosition.Before)"></li>
                        <li class="section-nav-row @GetDraggingClass(section.SectionId)" draggable="@(_orderedSections.Count > 1 ? "true" : "false")" @ondragstart="(args) => OnDragStart(section.SectionId, args)" @ondragend="OnDragEnd">
                            <button type="button"
                                    class="section-nav-item @GetActiveSectionClass(section.SectionId)"
                                    @onclick="() => OnSectionSelected(section.SectionId)">
                                <span class="section-order">@GetSectionOrderLabel(section)</span>
                                <span class="section-title">@GetSectionTitle(section)</span>
                            </button>
                            <div class="section-nav-actions">
                                <span class="drag-handle" aria-hidden="true">:::</span>
                                <button type="button" @onclick="() => OnMoveSectionUp(section.SectionId)" disabled="@IsFirstSection(section)">Up</button>
                                <button type="button" @onclick="() => OnMoveSectionDown(section.SectionId)" disabled="@IsLastSection(section)">Down</button>
                                <button type="button" @onclick="() => OnDeleteSection(section.SectionId)" disabled="@(_orderedSections.Count <= 1)">Delete</button>
                            </div>
                        </li>
                        <li class="drop-zone @(GetDropZoneClass(section.SectionId, DropPosition.After))" @ondragover="OnDragOver" @ondragover:preventDefault @ondragenter="() => OnDragEnter(section.SectionId, DropPosition.After)" @ondrop="() => OnDrop(section.SectionId, DropPosition.After)"></li>
                    }
                </ul>
            </div>
            <div class="editor-toolbar" role="toolbar" aria-label="Editor formatting">
                <div class="editor-toolbar-group" aria-label="Text emphasis">
                    <button type="button" class="@GetActiveClass(_formattingState.IsBold)" disabled="@(!_formattingState.CanBold)" @onclick="OnBoldRequested">Bold</button>
                    <button type="button" class="@GetActiveClass(_formattingState.IsItalic)" disabled="@(!_formattingState.CanItalic)" @onclick="OnItalicRequested">Italic</button>
                    <button type="button" class="@GetActiveClass(_formattingState.IsStrike)" disabled="@(!_formattingState.CanStrike)" @onclick="OnStrikeRequested">Strike</button>
                    <button type="button" class="@GetActiveClass(_formattingState.IsCode)" disabled="@(!_formattingState.CanCode)" @onclick="OnCodeRequested">Code</button>
                </div>
                <div class="editor-toolbar-group" aria-label="Structure">
                    <button type="button" class="@GetActiveClass(_formattingState.BlockType == "paragraph")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="OnParagraphRequested">Paragraph</button>
                    <button type="button" class="@GetActiveClass(_formattingState.BlockType == "heading:1")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="() => OnHeadingRequested(1)">H1</button>
                    <button type="button" class="@GetActiveClass(_formattingState.BlockType == "heading:2")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="() => OnHeadingRequested(2)">H2</button>
                    <button type="button" class="@GetActiveClass(_formattingState.BlockType == "heading:3")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="() => OnHeadingRequested(3)">H3</button>
                    <button type="button" class="@GetActiveClass(_formattingState.BlockType == "heading:4")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="() => OnHeadingRequested(4)">H4</button>
                    <button type="button" class="@GetActiveClass(_formattingState.BlockType == "heading:5")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="() => OnHeadingRequested(5)">H5</button>
                    <button type="button" class="@GetActiveClass(_formattingState.BlockType == "heading:6")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="() => OnHeadingRequested(6)">H6</button>
                    <button type="button" disabled="@(!_formattingState.CanBlockquote)" @onclick="OnBlockquoteRequested">Blockquote</button>
                    <button type="button" disabled="@(!_formattingState.CanHorizontalRule)" @onclick="OnHorizontalRuleRequested">Horizontal rule</button>
                </div>
                <div class="editor-toolbar-group" aria-label="Lists">
                    <button type="button" disabled="@(!_formattingState.CanToggleList)" @onclick="OnBulletListRequested">Bullet list</button>
                    <button type="button" disabled="@(!_formattingState.CanToggleList)" @onclick="OnOrderedListRequested">Ordered list</button>
                </div>
                <div class="editor-toolbar-group" aria-label="Typography">
                    <label class="editor-toolbar-label" for="fontFamilySelect">Font</label>
                    <select id="fontFamilySelect" class="editor-toolbar-select" value="@_fontFamily" @onchange="OnFontFamilyChanged">
                        <option value="mixed" disabled>Mixed</option>
                        <option value="">Default</option>
                        <option value="Georgia">Georgia</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Arial">Arial</option>
                        <option value="Helvetica">Helvetica</option>
                        <option value="Courier New">Courier New</option>
                    </select>
                    <label class="editor-toolbar-label" for="fontSizeSelect">Text size</label>
                    <select id="fontSizeSelect" class="editor-toolbar-select" value="@_fontSize" @onchange="OnFontSizeChanged">
                        <option value="mixed" disabled>Mixed</option>
                        <option value="12">12px</option>
                        <option value="14">14px</option>
                        <option value="16">16px</option>
                        <option value="18">18px</option>
                        <option value="24">24px</option>
                        <option value="32">32px</option>
                    </select>
                </div>
            </div>
            <div class="editor-actions">
                <button type="button" @onclick="OnUndo" disabled="@(!_commandProcessor.CanUndo)">Undo</button>
                <button type="button" @onclick="OnRedo" disabled="@(!_commandProcessor.CanRedo)">Redo</button>
                <button type="button" @onclick="OnSave">Save</button>
                @if (IsAiEnabled && _aiOptions.UI.ShowAiMenu && AiOrchestrator.CanRunAction(GenerateCoverImageAction.ActionIdValue))
                {
                    <button type="button" @onclick="OnGenerateCoverImage">Generate cover image (mock)</button>
                }
                <select class="editor-toolbar-select" value="@_selectedDocumentId" @onchange="OnSelectedDocumentChanged">
                    <option value="">Load document...</option>
                    @foreach (DocumentIndexEntry entry in _savedDocuments)
                    {
                        <option value="@entry.DocumentId.ToString()">@entry.Title</option>
                    }
                </select>
                <button type="button" @onclick="OnLoadSelected" disabled="@string.IsNullOrWhiteSpace(_selectedDocumentId)">Load</button>
            </div>
            <div class="editor-status">
                <span>@_wordCount words</span>
                <span>@_readingTime</span>
                <span class="@GetDirtyClass()">@GetDirtyLabel()</span>
                <span>@GetLastSavedLabel()</span>
            </div>
            @if (_pendingAiProposal is not null)
            {
                <div class="ai-preview">
                    <div class="ai-preview-header">
                        <strong>AI suggestion</strong>
                        <span>@_pendingAiProposal.Instruction</span>
                        @if (_isAiStreaming)
                        {
                            <span class="ai-preview-status">Generating...</span>
                        }
                        else if (!string.IsNullOrWhiteSpace(_aiStreamError))
                        {
                            <span class="ai-preview-status error">@_aiStreamError</span>
                        }
                    </div>
                    @if (!string.IsNullOrWhiteSpace(_pendingAiProposal.ProposedText))
                    {
                        <div class="ai-preview-columns">
                            <div class="ai-preview-pane">
                                <div class="ai-preview-label">Original</div>
                                <div class="ai-preview-text">@_pendingAiProposal.OriginalText</div>
                            </div>
                            <div class="ai-preview-pane">
                                <div class="ai-preview-label">Proposed</div>
                                <div class="ai-preview-text">@_pendingAiProposal.ProposedText</div>
                            </div>
                        </div>
                    }
                    @if (!string.IsNullOrWhiteSpace(_pendingAiProposal.ImageDataUrl))
                    {
                        <div class="ai-preview-image">
                            <div class="ai-preview-label">Proposed image</div>
                            <img src="@_pendingAiProposal.ImageDataUrl" alt="Proposed cover" />
                        </div>
                    }
                    <div class="ai-preview-actions">
                        <button type="button" @onclick="OnApplyPendingAiProposal" disabled="@(!_canApplyPendingAiProposal)">Apply</button>
                        <button type="button" @onclick="OnDiscardPendingAiProposal">Discard</button>
                    </div>
                </div>
            }
        </div>
        <div class="pane-body editor-scroll">
            <SectionEditor @ref="_editorRef"
                           Content="@_activeSectionContent"
                           ContentChanged="OnSectionContentChanged"
                           EditorReady="OnEditorReady"
                           FormattingChanged="OnFormattingChanged"
                           OutlineChanged="OnOutlineChanged"
                           SelectionChanged="OnSelectionChanged"
                           UndoRequested="OnUndo"
                           RedoRequested="OnRedo"
                           ContextMenuRequested="OnEditorContextMenuRequested" />
        </div>
    </div>
    <div class="preview-pane">
        <div class="pane-header">
            <h2>Document Preview</h2>
        </div>
        <div class="pane-body preview-scroll">
            <div class="outline-panel">
                <h3>Outline</h3>
                @if (_outlineItems.Count == 0)
                {
                    <div class="outline-empty">No headings</div>
                }
                else
                {
                    <ul class="outline-list">
                        @foreach (OutlineItem item in _outlineItems)
                        {
                            <li>
                                <button type="button" class="outline-item level-@item.Level" @onclick="() => OnOutlineSelected(item)">
                                    @item.Text
                                </button>
                            </li>
                        }
                    </ul>
                }
            </div>
            @if (GetCoverImageDataUrl(_activeSectionId) is string coverUrl)
            {
                <div class="cover-image-preview">
                    <img src="@coverUrl" alt="Cover image" />
                </div>
            }
            <div class="document-preview">
                @if (_previewSections is not null)
                {
                    for (int i = 0; i < _previewSections.Count; i++)
                    {
                        string html = _previewSections[i] ?? string.Empty;
                        <section class="document-section">
                            @((MarkupString)html)
                        </section>
                    }
                }
            </div>
        </div>
    </div>
</div>

@if (_isContextMenuOpen)
{
    <div class="editor-context-menu-backdrop" @onclick="CloseContextMenu"></div>
    <div class="editor-context-menu"
         style="@GetContextMenuStyle()"
         tabindex="-1"
         role="menu"
         @ref="_contextMenuRef"
         @onclick:stopPropagation="true"
         @onkeydown="OnContextMenuKeyDown">
        <div class="editor-context-menu-group">
            <div class="editor-context-menu-label">Text emphasis</div>
            <button type="button" class="@GetActiveClass(_formattingState.IsBold)" disabled="@(!_formattingState.CanBold)" @onclick="() => OnContextMenuCommand(OnBoldRequested)">Bold</button>
            <button type="button" class="@GetActiveClass(_formattingState.IsItalic)" disabled="@(!_formattingState.CanItalic)" @onclick="() => OnContextMenuCommand(OnItalicRequested)">Italic</button>
            <button type="button" class="@GetActiveClass(_formattingState.IsStrike)" disabled="@(!_formattingState.CanStrike)" @onclick="() => OnContextMenuCommand(OnStrikeRequested)">Strike</button>
            <button type="button" class="@GetActiveClass(_formattingState.IsCode)" disabled="@(!_formattingState.CanCode)" @onclick="() => OnContextMenuCommand(OnCodeRequested)">Code</button>
        </div>
        <div class="editor-context-menu-group">
            <div class="editor-context-menu-label">Structure</div>
            <button type="button" class="@GetActiveClass(_formattingState.BlockType == "paragraph")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="() => OnContextMenuCommand(OnParagraphRequested)">Paragraph</button>
            <button type="button" class="@GetActiveClass(_formattingState.BlockType == "heading:1")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="() => OnContextMenuCommand(() => OnHeadingRequested(1))">Heading 1</button>
            <button type="button" class="@GetActiveClass(_formattingState.BlockType == "heading:2")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="() => OnContextMenuCommand(() => OnHeadingRequested(2))">Heading 2</button>
            <button type="button" class="@GetActiveClass(_formattingState.BlockType == "heading:3")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="() => OnContextMenuCommand(() => OnHeadingRequested(3))">Heading 3</button>
        </div>
        <div class="editor-context-menu-group">
            <div class="editor-context-menu-label">Lists</div>
            <button type="button" disabled="@(!_formattingState.CanToggleList)" @onclick="() => OnContextMenuCommand(OnBulletListRequested)">Bullet list</button>
            <button type="button" disabled="@(!_formattingState.CanToggleList)" @onclick="() => OnContextMenuCommand(OnOrderedListRequested)">Ordered list</button>
        </div>
        <div class="editor-context-menu-group">
            <div class="editor-context-menu-label">Other</div>
            <button type="button" disabled="@(!_formattingState.CanBlockquote)" @onclick="() => OnContextMenuCommand(OnBlockquoteRequested)">Blockquote</button>
        </div>
        @if (_hasAiEditsAtSelection)
        {
            <div class="editor-context-menu-group">
                <div class="editor-context-menu-label">AI History</div>
                <button type="button" @onclick="() => OnContextMenuCommand(OnRollbackAiEdit)">Revert AI change</button>
                @if (_hasMultipleAiEditsInSection)
                {
                    <button type="button" @onclick="() => OnContextMenuCommand(OnRollbackAllAiEdits)">Revert all AI changes in this section</button>
                }
            </div>
        }
        @if (HostEnvironment.IsDevelopment())
        {
            <div class="editor-context-menu-group">
                <div class="editor-context-menu-label">AI (Test)</div>
                <button type="button" @onclick="() => OnContextMenuCommand(OnSimulateAiEdit)">Simulate AI edit (test)</button>
            </div>
        }
        @if (_currentSelectionRange is not null && CanShowAiMenu && AiOrchestrator.CanRunAction(RewriteSelectionAction.ActionIdValue))
        {
            <div class="editor-context-menu-group">
                <div class="editor-context-menu-label">AI</div>
                @foreach (AiActionOption action in _aiActions)
                {
                    <button type="button" @onclick="() => OnContextMenuCommand(() => OnAiActionSelected(action))">@action.Label</button>
                }
            </div>
        }
    </div>
}

<style>
    .editor-preview-layout {
        display: flex;
        gap: 32px;
        align-items: flex-start;
        padding: 24px;
    }

    .editor-pane,
    .preview-pane {
        flex: 1 1 0;
        min-width: 320px;
    }

    .editor-pane h2,
    .preview-pane h2 {
        margin-top: 0;
        font-size: 1.1rem;
        letter-spacing: 0.02em;
    }

    .pane-header {
        display: flex;
        flex-direction: column;
        gap: 12px;
        padding-bottom: 12px;
        border-bottom: 1px solid #ececec;
        position: sticky;
        top: 0;
        background: #fff;
        z-index: 2;
    }

    .pane-header h2 {
        margin: 0;
    }

    .pane-body {
        padding-top: 12px;
        max-height: 70vh;
        overflow: auto;
    }

    .editor-toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
    }

    .section-nav {
        border: 1px solid #ececec;
        border-radius: 6px;
        padding: 10px;
        background: #fafafa;
    }

    .section-nav-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
    }

    .section-nav-header h3 {
        margin: 0;
        font-size: 1rem;
    }

    .section-nav-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        gap: 6px;
    }

    .section-nav-row {
        display: flex;
        align-items: center;
        gap: 6px;
    }

    .drag-handle {
        width: 28px;
        height: 28px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        cursor: grab;
        background: #fff;
        user-select: none;
    }

    .drag-handle:disabled,
    .drag-handle[aria-disabled="true"] {
        cursor: not-allowed;
        opacity: 0.5;
    }

    .drop-zone {
        height: 6px;
        border-radius: 4px;
    }

    .drop-zone.is-active {
        background: #9bb6f0;
    }

    .section-nav-row.is-dragging .section-nav-item {
        opacity: 0.6;
    }

    .section-nav-item {
        flex: 1;
        display: flex;
        align-items: center;
        gap: 8px;
        text-align: left;
        padding: 6px 8px;
        border: 1px solid transparent;
        border-radius: 4px;
        background: #fff;
        cursor: pointer;
    }

    .section-nav-item.is-active {
        border-color: #9bb6f0;
        background: #e6eefc;
    }

    .section-order {
        font-size: 0.85rem;
        color: #6b6b6b;
        min-width: 24px;
    }

    .section-title {
        font-size: 0.95rem;
    }

    .section-nav-actions {
        display: flex;
        gap: 4px;
    }

    .editor-toolbar-group {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        padding-right: 10px;
        border-right: 1px solid #e3e3e3;
    }

    .editor-toolbar-group:last-child {
        padding-right: 0;
        border-right: none;
    }

    .editor-toolbar-label {
        align-self: center;
        font-size: 0.9rem;
    }

    .editor-toolbar-select {
        padding: 6px 8px;
        border: 1px solid #d0d0d0;
        border-radius: 4px;
        background: #fff;
        cursor: pointer;
    }

    .editor-actions {
        display: flex;
        gap: 8px;
        margin: 0;
    }

    .editor-status {
        display: flex;
        gap: 12px;
        font-size: 0.9rem;
        color: #5b5b5b;
    }

    .editor-actions button,
    .editor-toolbar button {
        padding: 6px 12px;
        border: 1px solid #d0d0d0;
        border-radius: 4px;
        background: #f8f8f8;
        cursor: pointer;
    }

    .section-nav-actions button,
    .section-nav-header button {
        padding: 4px 8px;
        border: 1px solid #d0d0d0;
        border-radius: 4px;
        background: #f8f8f8;
        cursor: pointer;
    }

    .section-nav-actions button:disabled,
    .section-nav-header button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .editor-actions select {
        padding: 6px 8px;
        border: 1px solid #d0d0d0;
        border-radius: 4px;
        background: #fff;
    }

    .editor-actions button:active,
    .editor-toolbar button:active {
        transform: translateY(1px);
    }

    .editor-toolbar button.is-active {
        background: #e6eefc;
        border-color: #9bb6f0;
    }

    .editor-toolbar button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .editor-context-menu-backdrop {
        position: fixed;
        inset: 0;
        z-index: 40;
    }

    .editor-context-menu {
        position: fixed;
        z-index: 41;
        min-width: 200px;
        padding: 6px;
        border: 1px solid #d6d6d6;
        border-radius: 6px;
        background: #fff;
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.12);
    }

    .editor-context-menu:focus {
        outline: none;
    }

    .editor-context-menu-group {
        display: flex;
        flex-direction: column;
        gap: 2px;
        padding: 4px 2px;
    }

    .editor-context-menu-group + .editor-context-menu-group {
        border-top: 1px solid #ececec;
        margin-top: 4px;
        padding-top: 6px;
    }

    .editor-context-menu-label {
        font-size: 0.75rem;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        color: #6b6b6b;
        padding: 4px 8px;
    }

    .editor-context-menu button {
        width: 100%;
        border: none;
        background: transparent;
        text-align: left;
        padding: 6px 8px;
        border-radius: 4px;
        cursor: pointer;
    }

    .editor-context-menu button:hover:not(:disabled) {
        background: #f0f3f8;
    }

    .editor-context-menu button.is-active {
        background: #e6eefc;
        color: #1f2a44;
    }

    .editor-context-menu button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .dirty-indicator {
        font-weight: 600;
        color: #b45309;
    }

    .clean-indicator {
        color: #4b5563;
    }

    .ai-edit-range {
        background: rgba(255, 204, 102, 0.25);
        border-radius: 2px;
    }

    .ai-edit-range.is-active {
        background: rgba(255, 204, 102, 0.55);
    }

    .ai-preview {
        border: 1px solid #e3e3e3;
        border-radius: 6px;
        padding: 12px;
        background: #fffaf0;
        display: grid;
        gap: 10px;
    }

    .ai-preview-header {
        display: flex;
        gap: 8px;
        align-items: baseline;
        font-size: 0.95rem;
    }

    .ai-preview-status {
        margin-left: auto;
        font-size: 0.85rem;
        color: #8a6d3b;
    }

    .ai-preview-status.error {
        color: #b00020;
    }

    .ai-preview-columns {
        display: grid;
        gap: 12px;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    }

    .ai-preview-pane {
        border: 1px solid #e8e8e8;
        border-radius: 4px;
        padding: 8px;
        background: #fff;
    }

    .ai-preview-label {
        font-size: 0.85rem;
        color: #6b6b6b;
        margin-bottom: 4px;
    }

    .ai-preview-text {
        font-size: 0.95rem;
        white-space: pre-wrap;
    }

    .ai-preview-image {
        border: 1px solid #e8e8e8;
        border-radius: 4px;
        padding: 8px;
        background: #fff;
        display: grid;
        gap: 6px;
    }

    .ai-preview-image img {
        max-width: 100%;
        height: auto;
        border-radius: 4px;
        border: 1px solid #eee;
    }

    .ai-preview-actions {
        display: flex;
        gap: 8px;
    }

    .editor-pane .ProseMirror {
        min-height: 320px;
        padding: 12px;
        border: 1px solid #d9d9d9;
        border-radius: 6px;
        background: #fff;
    }

    .document-preview {
        max-width: 760px;
        margin: 0 auto;
        padding: 24px 28px;
        line-height: 1.6;
        font-family: "Georgia", "Times New Roman", serif;
        background: #fff;
        color: #1e1e1e;
        border: 1px solid #e2e2e2;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.06);
    }

    .cover-image-preview {
        max-width: 760px;
        margin: 0 auto 16px;
        padding: 12px;
        background: #fff;
        border: 1px solid #e2e2e2;
        border-radius: 8px;
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.05);
    }

    .cover-image-preview img {
        width: 100%;
        height: auto;
        display: block;
        border-radius: 6px;
    }

    .document-section {
        margin-bottom: 28px;
        padding-bottom: 8px;
        border-bottom: 1px solid #f0f0f0;
    }

    .document-section:last-child {
        border-bottom: none;
        margin-bottom: 0;
        padding-bottom: 0;
    }

    .outline-panel {
        margin-bottom: 16px;
        padding: 12px;
        border: 1px solid #ececec;
        border-radius: 6px;
        background: #fafafa;
    }

    .outline-panel h3 {
        margin: 0 0 8px 0;
        font-size: 1rem;
    }

    .outline-list {
        list-style: none;
        margin: 0;
        padding: 0;
    }

    .outline-item {
        display: block;
        width: 100%;
        text-align: left;
        padding: 4px 6px;
        border: 1px solid transparent;
        border-radius: 4px;
        background: transparent;
        cursor: pointer;
    }

    .outline-item:hover {
        background: #f0f3f8;
        border-color: #d7dbe2;
    }

    .outline-item.level-1 { padding-left: 4px; }
    .outline-item.level-2 { padding-left: 16px; }
    .outline-item.level-3 { padding-left: 28px; }
    .outline-item.level-4 { padding-left: 40px; }
    .outline-item.level-5 { padding-left: 52px; }
    .outline-item.level-6 { padding-left: 64px; }

    .outline-empty {
        font-size: 0.9rem;
        color: #7a7a7a;
    }

    @@media (max-width: 900px) {
        .editor-preview-layout {
            flex-direction: column;
        }

        .pane-body {
            max-height: none;
        }
    }
</style>

@code {
    private DocumentState _state;
    private CommandProcessor _commandProcessor;
    private readonly Action _onChangedHandler;
    private readonly List<string> _previewSections = new();
    private readonly List<OutlineItem> _outlineItems = new();
    private readonly List<Section> _orderedSections = new();
    private SectionEditor? _editorRef;
    private Guid _activeSectionId;
    private string _activeSectionContent = string.Empty;
    private bool _suppressEditorEvent;
    private bool _skipNextEditorSync;
    private IJSObjectReference? _editorInstance;
    private IJSObjectReference? _commandsModule;
    private bool _disposed;
    private string _fontSize = "16";
    private string _fontFamily = string.Empty;
    private EditorFormattingState _formattingState = new()
    {
        CanBold = true,
        CanItalic = true,
        CanStrike = true,
        CanCode = true,
        CanApplyHeading = true,
        CanToggleList = true,
        CanBlockquote = true,
        CanHorizontalRule = true
    };
    private bool _loadedFromStorage;
    private int _wordCount;
    private string _readingTime = "0 min read";
    private string _selectedDocumentId = string.Empty;
    private readonly List<DocumentIndexEntry> _savedDocuments = new();
    private bool _isDirty;
    private DateTime _lastSavedUtc;
    private bool _suppressDirtyUpdate;
    private Guid? _draggingSectionId;
    private Guid? _dropTargetSectionId;
    private DropPosition? _dropPosition;
    private bool _isContextMenuOpen;
    private double _contextMenuX;
    private double _contextMenuY;
    private ElementReference _contextMenuRef;
    private bool _shouldFocusContextMenu;
    private TextRange? _currentSelectionRange;
    private bool _hasAiEditsAtSelection;
    private bool _hasMultipleAiEditsInSection;
    private Guid? _aiRollbackGroupId;
    private bool _isReordering;
    private PendingAiProposal? _pendingAiProposal;
    private CancellationTokenSource? _aiStreamCts;
    private bool _isAiStreaming;
    private string? _aiStreamError;
    private string _streamedText = string.Empty;
    private string? _streamedImageReference;
    private readonly List<AiActionOption> _aiActions = new()
    {
        new AiActionOption("Rewrite (Neutral)", "Rewrite (Neutral)", AiActionScope.Selection, new Dictionary<string, object?>
        {
            ["tone"] = "Neutral",
            ["length"] = "Same",
            ["preserve_terms"] = true
        }),
        new AiActionOption("Rewrite (Formal)", "Rewrite (Formal)", AiActionScope.Selection, new Dictionary<string, object?>
        {
            ["tone"] = "Formal",
            ["length"] = "Same",
            ["preserve_terms"] = true
        }),
        new AiActionOption("Rewrite (Casual)", "Rewrite (Casual)", AiActionScope.Selection, new Dictionary<string, object?>
        {
            ["tone"] = "Casual",
            ["length"] = "Same",
            ["preserve_terms"] = true
        }),
        new AiActionOption("Rewrite (Executive)", "Rewrite (Executive)", AiActionScope.Selection, new Dictionary<string, object?>
        {
            ["tone"] = "Executive",
            ["length"] = "Same",
            ["preserve_terms"] = true
        }),
        new AiActionOption("Shorten (Neutral)", "Shorten (Neutral)", AiActionScope.Selection, new Dictionary<string, object?>
        {
            ["tone"] = "Neutral",
            ["length"] = "Shorter",
            ["preserve_terms"] = true
        }),
        new AiActionOption("Fix grammar (Neutral)", "Fix grammar (Neutral)", AiActionScope.Selection, new Dictionary<string, object?>
        {
            ["tone"] = "Neutral",
            ["length"] = "Same",
            ["preserve_terms"] = true
        }),
        new AiActionOption("Change tone (Friendly)", "Change tone (Friendly)", AiActionScope.Selection, new Dictionary<string, object?>
        {
            ["tone"] = "Friendly",
            ["length"] = "Same",
            ["preserve_terms"] = true
        }),
        new AiActionOption("Change tone (Technical)", "Change tone (Technical)", AiActionScope.Selection, new Dictionary<string, object?>
        {
            ["tone"] = "Technical",
            ["length"] = "Same",
            ["preserve_terms"] = true
        })
    };
    private const string StorageKey = "writerapp.document";
    private const string StorageIndexKey = "writerapp.document.index";
    private const string StoragePrefix = "writerapp.document.";
    private WriterAiOptions _aiOptions = new();

    public Home()
    {
        Document document = CreateSampleDocument();
        _state = new DocumentState(document);
        _commandProcessor = new CommandProcessor(_state);
        _onChangedHandler = () => _ = HandleDocumentChangedAsync();
        _state.OnChanged += _onChangedHandler;

        if (document.Chapters.Count > 0 && document.Chapters[0].Sections.Count > 0)
        {
            _activeSectionId = document.Chapters[0].Sections[0].SectionId;
        }

        _lastSavedUtc = document.Metadata.ModifiedUtc;
    }

    protected override void OnInitialized()
    {
        _aiOptions = AiOptions.Value;
        RefreshFromDocument(_state.Document);
        _lastSavedUtc = _state.Document.Metadata.ModifiedUtc;
        _isDirty = false;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_loadedFromStorage)
        {
            _loadedFromStorage = true;
            await LoadDocumentIndexAsync();
            await LoadDocumentAsync();
        }

        if (_shouldFocusContextMenu)
        {
            _shouldFocusContextMenu = false;
            await _contextMenuRef.FocusAsync();
        }
    }

    private Task OnSectionContentChanged(string html)
    {
        return ExecuteSafeAsync("OnSectionContentChanged", () =>
        {
            if (_suppressEditorEvent || _disposed)
            {
                return Task.CompletedTask;
            }

            string content = html ?? string.Empty;
            Section section = FindSection(_state.Document, _activeSectionId);
            if (string.Equals(section.Content.Value, content, StringComparison.Ordinal))
            {
                return Task.CompletedTask;
            }

            _skipNextEditorSync = true;
            _commandProcessor.Execute(new UpdateSectionContentCommand(_activeSectionId, content));
            return Task.CompletedTask;
        });
    }

    private Task OnUndo()
    {
        return ExecuteSafeAsync("OnUndo", () =>
        {
            if (_commandProcessor.CanUndo)
            {
                _commandProcessor.Undo();
                return InvokeCommandAsync("focusEditor");
            }

            return Task.CompletedTask;
        });
    }

    private Task OnRedo()
    {
        return ExecuteSafeAsync("OnRedo", () =>
        {
            if (_commandProcessor.CanRedo)
            {
                _commandProcessor.Redo();
                return InvokeCommandAsync("focusEditor");
            }

            return Task.CompletedTask;
        });
    }

    private Task OnFontSizeChanged(ChangeEventArgs args)
    {
        return ExecuteSafeAsync("OnFontSizeChanged", async () =>
        {
            if (args.Value is null)
            {
                return;
            }

            string? value = args.Value.ToString();
            if (string.Equals(value, "mixed", StringComparison.Ordinal))
            {
                return;
            }

            if (int.TryParse(value, out int size))
            {
                _fontSize = size.ToString(CultureInfo.InvariantCulture);
                await InvokeCommandAsync("setFontSize", size);
            }
        });
    }

    private Task OnFontFamilyChanged(ChangeEventArgs args)
    {
        return ExecuteSafeAsync("OnFontFamilyChanged", async () =>
        {
            string? family = args.Value?.ToString();
            _fontFamily = family ?? string.Empty;

            if (string.Equals(_fontFamily, "mixed", StringComparison.Ordinal))
            {
                return;
            }

            if (string.IsNullOrWhiteSpace(_fontFamily))
            {
                await InvokeCommandAsync("clearFontFamily");
                return;
            }

            await InvokeCommandAsync("setFontFamily", _fontFamily);
        });
    }

    private void OnSelectedDocumentChanged(ChangeEventArgs args)
    {
        ExecuteSafe("OnSelectedDocumentChanged", () =>
        {
            _selectedDocumentId = args.Value?.ToString() ?? string.Empty;
        });
    }

    private Task OnLoadSelected()
    {
        return ExecuteSafeAsync("OnLoadSelected", async () =>
        {
            if (string.IsNullOrWhiteSpace(_selectedDocumentId))
            {
                return;
            }

            await LoadDocumentByIdAsync(_selectedDocumentId);
        });
    }

    private Task OnSectionSelected(Guid sectionId)
    {
        return ExecuteSafeAsync("OnSectionSelected", async () =>
        {
            if (sectionId == _activeSectionId)
            {
                return;
            }

            _commandProcessor.ClearHistory();
            _activeSectionId = sectionId;
            _pendingAiProposal = null;
            _skipNextEditorSync = false;
            _suppressDirtyUpdate = true;
            _currentSelectionRange = null;
            _state.NotifyChanged();
            await InvokeCommandAsync("focusEditor");
        });
    }

    private Task OnMoveSectionUp(Guid sectionId)
    {
        return ExecuteSafeAsync("OnMoveSectionUp", () => MoveSectionAsync(sectionId, -1));
    }

    private Task OnMoveSectionDown(Guid sectionId)
    {
        return ExecuteSafeAsync("OnMoveSectionDown", () => MoveSectionAsync(sectionId, 1));
    }

    private Task OnCreateSection()
    {
        return ExecuteSafeAsync("OnCreateSection", async () =>
        {
            Chapter chapter = GetPrimaryChapter();
            List<Section> ordered = _orderedSections.Count > 0
                ? new List<Section>(_orderedSections)
                : chapter.Sections.OrderBy(section => section.Order).ToList();

            int insertIndex = ordered.FindIndex(section => section.SectionId == _activeSectionId);
            if (insertIndex < 0)
            {
                insertIndex = ordered.Count - 1;
            }

            Section newSection = new()
            {
                SectionId = Guid.NewGuid(),
                Order = insertIndex + 1,
                Title = string.Empty,
                Content = new SectionContent { Format = "html", Value = "<p></p>" },
                Stats = new SectionStats(),
                Flags = new SectionFlags(),
                AI = new SectionAIInfo(),
                CreatedUtc = DateTime.UtcNow,
                ModifiedUtc = DateTime.UtcNow
            };

            ordered.Insert(insertIndex + 1, newSection);
            chapter.Sections.Add(newSection);
            ApplySectionOrdering(ordered, chapter);

            _activeSectionId = newSection.SectionId;
            _commandProcessor.ClearHistory();
            _state.NotifyChanged();
            await InvokeCommandAsync("focusEditor");
        });
    }

    private Task OnDeleteSection(Guid sectionId)
    {
        return ExecuteSafeAsync("OnDeleteSection", async () =>
        {
            if (_orderedSections.Count <= 1)
            {
                return;
            }

            bool confirmed;
            try
            {
                confirmed = await JSRuntime.InvokeAsync<bool>("confirm", "Delete this section?");
            }
            catch (JSException ex)
            {
                Logger.LogWarning(ex, "Delete confirmation failed.");
                return;
            }

            if (!confirmed)
            {
                return;
            }

            Chapter chapter = GetPrimaryChapter();
            List<Section> ordered = _orderedSections.Count > 0
                ? new List<Section>(_orderedSections)
                : chapter.Sections.OrderBy(section => section.Order).ToList();

            int removeIndex = ordered.FindIndex(section => section.SectionId == sectionId);
            if (removeIndex < 0)
            {
                return;
            }

            ordered.RemoveAt(removeIndex);
            chapter.Sections.RemoveAll(section => section.SectionId == sectionId);
            ApplySectionOrdering(ordered, chapter);

            if (sectionId == _activeSectionId)
            {
                int nextIndex = Math.Min(removeIndex, ordered.Count - 1);
                _activeSectionId = ordered[nextIndex].SectionId;
            }

            _commandProcessor.ClearHistory();
            _state.NotifyChanged();
            await InvokeCommandAsync("focusEditor");
        });
    }

    private Task MoveSectionAsync(Guid sectionId, int direction)
    {
        return ExecuteSafeAsync("MoveSectionAsync", async () =>
        {
            if (_orderedSections.Count <= 1 || direction == 0)
            {
                return;
            }

            Chapter chapter = GetPrimaryChapter();
            List<Section> ordered = _orderedSections.Count > 0
                ? new List<Section>(_orderedSections)
                : chapter.Sections.OrderBy(section => section.Order).ToList();

            int index = ordered.FindIndex(section => section.SectionId == sectionId);
            int targetIndex = index + direction;
            if (index < 0 || targetIndex < 0 || targetIndex >= ordered.Count)
            {
                return;
            }

            Section section = ordered[index];
            ordered.RemoveAt(index);
            ordered.Insert(targetIndex, section);

            _commandProcessor.Execute(new ReorderSectionsCommand(
                chapter.ChapterId,
                ordered.Select(entry => entry.SectionId).ToList()));
        });
    }

    private void OnDragStart(Guid sectionId, DragEventArgs args)
    {
        ExecuteSafe("OnDragStart", () =>
        {
            Logger.LogInformation("DragStart: section {SectionId}", sectionId);
            if (_orderedSections.Count <= 1)
            {
                Logger.LogInformation("DragStart ignored: only one section.");
                return;
            }

            _draggingSectionId = sectionId;
            _dropTargetSectionId = null;
            _dropPosition = null;

            if (args.DataTransfer is not null)
            {
                args.DataTransfer.DropEffect = "move";
                args.DataTransfer.EffectAllowed = "move";
            }

            _ = InvokeAsync(StateHasChanged);
        });
    }

    private void OnDragEnd(DragEventArgs args)
    {
        ExecuteSafe("OnDragEnd", () =>
        {
            Logger.LogInformation("DragEnd: dragging {SectionId}", _draggingSectionId);
            _draggingSectionId = null;
            _dropTargetSectionId = null;
            _dropPosition = null;
            _ = InvokeAsync(StateHasChanged);
        });
    }

    private void OnDragEnter(Guid targetSectionId, DropPosition position)
    {
        ExecuteSafe("OnDragEnter", () =>
        {
            Logger.LogInformation("DragEnter: target {TargetSectionId} position {Position}", targetSectionId, position);
            if (_draggingSectionId is null || _draggingSectionId == targetSectionId)
            {
                Logger.LogInformation("DragEnter ignored: dragging {DraggingSectionId}", _draggingSectionId);
                return;
            }

            _dropTargetSectionId = targetSectionId;
            _dropPosition = position;
            _ = InvokeAsync(StateHasChanged);
        });
    }

    private void OnDragOver(DragEventArgs args)
    {
        ExecuteSafe("OnDragOver", () =>
        {
            if (args.DataTransfer is not null)
            {
                args.DataTransfer.DropEffect = "move";
            }
        });
    }

    private Task OnDrop(Guid targetSectionId, DropPosition position)
    {
        return ExecuteSafeAsync("OnDrop", async () =>
        {
            Logger.LogInformation("Drop: target {TargetSectionId} position {Position} dragging {DraggingSectionId}", targetSectionId, position, _draggingSectionId);
            if (_draggingSectionId is null || _draggingSectionId == targetSectionId)
            {
                Logger.LogInformation("Drop ignored: invalid dragging state.");
                return;
            }

            Guid sourceSectionId = _draggingSectionId.Value;
            _draggingSectionId = null;
            _dropTargetSectionId = null;
            _dropPosition = null;

            Chapter chapter = GetPrimaryChapter();
            List<Section> ordered = new(_orderedSections);
            int sourceIndex = ordered.FindIndex(section => section.SectionId == sourceSectionId);
            int targetIndex = ordered.FindIndex(section => section.SectionId == targetSectionId);
            if (sourceIndex < 0 || targetIndex < 0)
            {
                Logger.LogWarning("Drop aborted: sourceIndex {SourceIndex} targetIndex {TargetIndex}", sourceIndex, targetIndex);
                return;
            }

            Section moving = ordered[sourceIndex];
            ordered.RemoveAt(sourceIndex);
            if (sourceIndex < targetIndex)
            {
                targetIndex -= 1;
            }

            int insertIndex = position == DropPosition.Before ? targetIndex : targetIndex + 1;
            insertIndex = Math.Clamp(insertIndex, 0, ordered.Count);
            Logger.LogInformation("Drop reorder: source {SourceIndex} target {TargetIndex} insert {InsertIndex}", sourceIndex, targetIndex, insertIndex);
            ordered.Insert(insertIndex, moving);

            _commandProcessor.Execute(new ReorderSectionsCommand(
                chapter.ChapterId,
                ordered.Select(entry => entry.SectionId).ToList()));
        });
    }

    private string GetDropZoneClass(Guid sectionId, DropPosition position)
    {
        if (_dropTargetSectionId == sectionId && _dropPosition == position)
        {
            return "is-active";
        }

        return string.Empty;
    }

    private string GetDraggingClass(Guid sectionId)
    {
        return _draggingSectionId == sectionId ? "is-dragging" : string.Empty;
    }

    private enum DropPosition
    {
        Before,
        After
    }

    private Chapter GetPrimaryChapter()
    {
        if (_state.Document.Chapters.Count == 0)
        {
            Chapter chapter = new() { Order = 0, Title = "Draft" };
            _state.Document.Chapters.Add(chapter);
            return chapter;
        }

        return _state.Document.Chapters[0];
    }

    private void ApplySectionOrdering(List<Section> ordered, Chapter chapter)
    {
        Dictionary<Guid, Section> updates = new();
        for (int i = 0; i < ordered.Count; i++)
        {
            Section updated = ordered[i] with { Order = i };
            updates[updated.SectionId] = updated;
        }

        for (int i = 0; i < chapter.Sections.Count; i++)
        {
            Section section = chapter.Sections[i];
            if (updates.TryGetValue(section.SectionId, out Section updated))
            {
                chapter.Sections[i] = updated;
            }
        }
    }

    private bool IsFirstSection(Section section) => _orderedSections.Count == 0 || _orderedSections[0].SectionId == section.SectionId;

    private bool IsLastSection(Section section) => _orderedSections.Count == 0 || _orderedSections[^1].SectionId == section.SectionId;

    private string GetActiveSectionClass(Guid sectionId) => sectionId == _activeSectionId ? "is-active" : string.Empty;

    private string GetSectionOrderLabel(Section section) => (section.Order + 1).ToString(CultureInfo.InvariantCulture);

    private string GetSectionTitle(Section section)
    {
        if (!string.IsNullOrWhiteSpace(section.Title))
        {
            return section.Title;
        }

        string? derived = DeriveTitleFromSection(section.Content.Value);
        return string.IsNullOrWhiteSpace(derived) ? "Untitled section" : derived;
    }

    private static string? DeriveTitleFromSection(string? html)
    {
        if (string.IsNullOrWhiteSpace(html))
        {
            return null;
        }

        Match match = Regex.Match(html, "<h[1-6][^>]*>(.*?)</h[1-6]>", RegexOptions.IgnoreCase | RegexOptions.Singleline);
        if (!match.Success)
        {
            return null;
        }

        string plain = ExtractPlainText(match.Groups[1].Value);
        if (string.IsNullOrWhiteSpace(plain))
        {
            return null;
        }

        plain = Regex.Replace(plain, @"\s+", " ").Trim();
        if (plain.Length > 60)
        {
            plain = plain.Substring(0, 60).Trim();
        }

        return plain;
    }

    private Task OnOutlineChanged(List<OutlineItem> outline)
    {
        return ExecuteSafeAsync("OnOutlineChanged", () =>
        {
            if (_disposed)
            {
                return Task.CompletedTask;
            }

            _outlineItems.Clear();
            if (outline is not null)
            {
                _outlineItems.AddRange(outline);
            }

            return InvokeAsync(StateHasChanged);
        });
    }

    private Task OnOutlineSelected(OutlineItem item)
    {
        return ExecuteSafeAsync("OnOutlineSelected", () =>
        {
            if (item is null || _disposed)
            {
                return Task.CompletedTask;
            }

            return InvokeCommandAsync("scrollToPosition", item.Position);
        });
    }

    private Task OnFormattingChanged(EditorFormattingState state)
    {
        return ExecuteSafeAsync("OnFormattingChanged", () =>
        {
            if (_disposed)
            {
                return Task.CompletedTask;
            }

            _formattingState = state ?? new EditorFormattingState();
            _fontFamily = _formattingState.FontFamily is null
                ? "mixed"
                : string.IsNullOrWhiteSpace(_formattingState.FontFamily) ? string.Empty : _formattingState.FontFamily;
            _fontSize = _formattingState.FontSize is null
                ? "mixed"
                : string.IsNullOrWhiteSpace(_formattingState.FontSize) ? "16" : _formattingState.FontSize;

            return InvokeAsync(StateHasChanged);
        });
    }

    private Task OnSelectionChanged(SectionEditor.EditorSelectionRange range)
    {
        return ExecuteSafeAsync("OnSelectionChanged", () =>
        {
            if (_disposed)
            {
                return Task.CompletedTask;
            }

            UpdateSelectionRange(range.Start, range.End);
            UpdateAiContextMenuState();
            return UpdateAiDecorationsAsync();
        });
    }

    private static string GetActiveClass(bool isActive) => isActive ? "is-active" : string.Empty;

    private string GetContextMenuStyle()
    {
        string left = _contextMenuX.ToString(CultureInfo.InvariantCulture);
        string top = _contextMenuY.ToString(CultureInfo.InvariantCulture);
        return $"left: {left}px; top: {top}px;";
    }

    private Task OnEditorContextMenuRequested(SectionEditor.EditorContextMenuRequest request)
    {
        return ExecuteSafeAsync("OnEditorContextMenuRequested", () =>
        {
            UpdateAiContextMenuState();
            _isContextMenuOpen = true;
            _contextMenuX = request.X;
            _contextMenuY = request.Y;
            _shouldFocusContextMenu = true;
            return InvokeAsync(StateHasChanged);
        });
    }

    private void CloseContextMenu()
    {
        _isContextMenuOpen = false;
    }

    private async Task OnContextMenuCommand(Func<Task> command)
    {
        CloseContextMenu();
        if (command is null)
        {
            return;
        }

        await command();
    }

    private Task OnRollbackAiEdit()
    {
        return ExecuteSafeAsync("OnRollbackAiEdit", () =>
        {
            if (_aiRollbackGroupId is null)
            {
                return Task.CompletedTask;
            }

            _commandProcessor.RollbackAiEditGroup(_activeSectionId, _aiRollbackGroupId.Value);
            return InvokeCommandAsync("focusEditor");
        });
    }

    private Task OnRollbackAllAiEdits()
    {
        return ExecuteSafeAsync("OnRollbackAllAiEdits", () =>
        {
            _commandProcessor.RollbackAllAiEdits(_activeSectionId);
            return InvokeCommandAsync("focusEditor");
        });
    }

    private Task OnAiActionSelected(AiActionOption action)
    {
        return ExecuteSafeAsync("OnAiActionSelected", async () =>
        {
            if (!IsAiEnabled)
            {
                ShowAiMessage("AI is disabled by configuration.");
                await InvokeAsync(StateHasChanged);
                return;
            }

            if (_currentSelectionRange is null)
            {
                return;
            }

            if (!AiOrchestrator.CanRunAction(RewriteSelectionAction.ActionIdValue))
            {
                return;
            }

            string plainText = PlainTextMapper.ToPlainText(_activeSectionContent);
            if (plainText.Length == 0)
            {
                return;
            }

            CancelAiStream();

            TextRange normalized = NormalizeRange(_currentSelectionRange, plainText.Length);
            TextRange selectionRange = ResolveSelectionRange(action, normalized, plainText.Length);
            string originalText = ExtractRangeText(plainText, selectionRange);

            AiActionInput input = new(
                _state.Document,
                _activeSectionId,
                selectionRange,
                originalText,
                action.Instruction,
                action.Inputs);

            AiStreamingCapabilities streamingCapabilities = AiOrchestrator.GetStreamingCapabilities(RewriteSelectionAction.ActionIdValue);
            if (streamingCapabilities.SupportsTextStreaming)
            {
                bool started = await StartAiStreamingAsync(
                    RewriteSelectionAction.ActionIdValue,
                    input,
                    BuildActionLabel(action),
                    originalText);
                if (!started)
                {
                    await InvokeAsync(StateHasChanged);
                }

                return;
            }

            AiProposal proposal;
            try
            {
                proposal = await AiOrchestrator.ExecuteActionAsync(
                    RewriteSelectionAction.ActionIdValue,
                    input,
                    CancellationToken.None);
            }
            catch (InvalidOperationException ex)
            {
                ShowAiMessage(ex.Message);
                await InvokeAsync(StateHasChanged);
                return;
            }

            _pendingAiProposal = new PendingAiProposal(
                proposal,
                BuildActionLabel(action),
                originalText,
                GetProposedText(proposal),
                GetImageDataUrl(proposal),
                DateTime.UtcNow);
            _aiStreamError = null;

            await InvokeAsync(StateHasChanged);
        });
    }

    private Task OnGenerateCoverImage()
    {
        return ExecuteSafeAsync("OnGenerateCoverImage", async () =>
        {
            if (!IsAiEnabled)
            {
                ShowAiMessage("AI is disabled by configuration.");
                await InvokeAsync(StateHasChanged);
                return;
            }

            if (!AiOrchestrator.CanRunAction(GenerateCoverImageAction.ActionIdValue))
            {
                return;
            }

            CancelAiStream();

            string plainText = PlainTextMapper.ToPlainText(_activeSectionContent);
            TextRange selectionRange = new(0, Math.Max(0, plainText.Length));

            AiActionInput input = new(
                _state.Document,
                _activeSectionId,
                selectionRange,
                string.Empty,
                "Generate cover image",
                null);

            AiStreamingCapabilities streamingCapabilities = AiOrchestrator.GetStreamingCapabilities(GenerateCoverImageAction.ActionIdValue);
            if (streamingCapabilities.SupportsImageStreaming)
            {
                bool started = await StartAiStreamingAsync(
                    GenerateCoverImageAction.ActionIdValue,
                    input,
                    "Generate cover image",
                    string.Empty);
                if (!started)
                {
                    await InvokeAsync(StateHasChanged);
                }

                return;
            }

            AiProposal proposal;
            try
            {
                proposal = await AiOrchestrator.ExecuteActionAsync(
                    GenerateCoverImageAction.ActionIdValue,
                    input,
                    CancellationToken.None);
            }
            catch (InvalidOperationException ex)
            {
                ShowAiMessage(ex.Message);
                await InvokeAsync(StateHasChanged);
                return;
            }

            _pendingAiProposal = new PendingAiProposal(
                proposal,
                "Generate cover image",
                string.Empty,
                GetProposedText(proposal),
                GetImageDataUrl(proposal),
                DateTime.UtcNow);
            _aiStreamError = null;

            if (proposal.ArtifactIds.Count > 0)
            {
                AiAttachmentStore.SetCoverImageId(_activeSectionId, proposal.ArtifactIds[0]);
            }

            await InvokeAsync(StateHasChanged);
        });
    }

    private bool _canApplyPendingAiProposal => !_isAiStreaming && _pendingAiProposal?.Proposal is not null;

    private Task OnApplyPendingAiProposal()
    {
        return ExecuteSafeAsync("OnApplyPendingAiProposal", () =>
        {
            if (_pendingAiProposal is null)
            {
                return Task.CompletedTask;
            }

            PendingAiProposal pending = _pendingAiProposal;
            if (_isAiStreaming || pending.Proposal is null)
            {
                return Task.CompletedTask;
            }

            _pendingAiProposal = null;
            AiProposalApplier.Apply(_commandProcessor, pending.Proposal);
            AiAttachmentStore.SetCoverImageId(pending.Proposal.SectionId, null);

            return InvokeCommandAsync("focusEditor");
        });
    }

    private Task OnDiscardPendingAiProposal()
    {
        return ExecuteSafeAsync("OnDiscardPendingAiProposal", () =>
        {
            CancelAiStream();
            _pendingAiProposal = null;
            _aiStreamError = null;
            AiAttachmentStore.SetCoverImageId(_activeSectionId, null);
            return InvokeAsync(StateHasChanged);
        });
    }

    private async Task<bool> StartAiStreamingAsync(
        string actionId,
        AiActionInput input,
        string instructionLabel,
        string originalText)
    {
        CancelAiStream();

        CancellationTokenSource cts = new();
        _aiStreamCts = cts;
        _isAiStreaming = true;
        _aiStreamError = null;
        _streamedText = string.Empty;
        _streamedImageReference = null;

        // Preview updates stream into the panel; apply is only enabled after completion.
        _pendingAiProposal = new PendingAiProposal(
            null,
            instructionLabel,
            originalText,
            null,
            null,
            DateTime.UtcNow);

        await InvokeAsync(StateHasChanged);

        AiStreamingSession session;
        try
        {
            session = AiOrchestrator.StreamActionAsync(actionId, input, cts.Token);
        }
        catch (InvalidOperationException ex)
        {
            ShowAiMessage(ex.Message);
            return false;
        }

        try
        {
            await foreach (AiStreamEvent streamEvent in session.Events.WithCancellation(cts.Token))
            {
                switch (streamEvent)
                {
                    case AiStreamEvent.TextDelta textDelta:
                        if (!string.IsNullOrEmpty(textDelta.Delta))
                        {
                            _streamedText += textDelta.Delta;
                            if (_pendingAiProposal is not null)
                            {
                                _pendingAiProposal = _pendingAiProposal with { ProposedText = _streamedText };
                            }
                        }

                        break;
                    case AiStreamEvent.ImageDelta imageDelta:
                        if (!string.IsNullOrWhiteSpace(imageDelta.Reference))
                        {
                            _streamedImageReference = imageDelta.Reference;
                            if (_pendingAiProposal is not null)
                            {
                                _pendingAiProposal = _pendingAiProposal with { ImageDataUrl = imageDelta.Reference };
                            }
                        }

                        break;
                    case AiStreamEvent.Failed failed:
                        _aiStreamError = failed.Error;
                        break;
                }

                await InvokeAsync(StateHasChanged);
            }
        }
        catch (OperationCanceledException)
        {
            return false;
        }
        finally
        {
            if (_aiStreamCts == cts)
            {
                _aiStreamCts = null;
                _isAiStreaming = false;
            }
        }

        if (cts.IsCancellationRequested)
        {
            return false;
        }

        AiProposal? proposal = await session.Completion;
        if (proposal is null)
        {
            await InvokeAsync(StateHasChanged);
            return false;
        }

        string? proposedText = GetProposedText(proposal);
        string? imageDataUrl = GetImageDataUrl(proposal);

        _pendingAiProposal = new PendingAiProposal(
            proposal,
            instructionLabel,
            originalText,
            proposedText,
            imageDataUrl,
            DateTime.UtcNow);

        if (proposal.ArtifactIds.Count > 0)
        {
            AiAttachmentStore.SetCoverImageId(_activeSectionId, proposal.ArtifactIds[0]);
        }

        await InvokeAsync(StateHasChanged);
        return true;
    }

    private bool IsAiEnabled => _aiOptions.Enabled;

    private bool CanShowAiMenu => _aiOptions.Enabled && _aiOptions.UI.ShowAiMenu;

    private void ShowAiMessage(string message)
    {
        CancelAiStream();
        _aiStreamError = message;
        _pendingAiProposal = new PendingAiProposal(
            null,
            "AI",
            string.Empty,
            null,
            null,
            DateTime.UtcNow);
    }

    private void CancelAiStream()
    {
        if (_aiStreamCts is null)
        {
            return;
        }

        _aiStreamCts.Cancel();
        _aiStreamCts.Dispose();
        _aiStreamCts = null;
        _isAiStreaming = false;
    }

    private static TextRange NormalizeRange(TextRange range, int sectionLength)
    {
        int start = Math.Clamp(range.Start, 0, sectionLength);
        int end = Math.Clamp(range.Start + range.Length, 0, sectionLength);
        if (end < start)
        {
            (start, end) = (end, start);
        }

        return new TextRange(start, Math.Max(0, end - start));
    }

    private static TextRange ResolveSelectionRange(AiActionOption action, TextRange selection, int sectionLength)
    {
        if (action.Scope == AiActionScope.Section)
        {
            return new TextRange(0, Math.Max(0, sectionLength));
        }

        if (selection.Length == 0)
        {
            return new TextRange(0, Math.Max(0, sectionLength));
        }

        return selection;
    }

    private static string ExtractRangeText(string plainText, TextRange range)
    {
        if (string.IsNullOrEmpty(plainText))
        {
            return string.Empty;
        }

        int start = Math.Clamp(range.Start, 0, plainText.Length);
        int end = Math.Clamp(range.Start + range.Length, 0, plainText.Length);
        if (end < start)
        {
            (start, end) = (end, start);
        }

        return plainText.Substring(start, Math.Max(0, end - start));
    }

    private static string? GetProposedText(AiProposal proposal)
    {
        for (int index = 0; index < proposal.Operations.Count; index++)
        {
            if (proposal.Operations[index] is ReplaceTextRangeOperation replaceOperation)
            {
                return replaceOperation.NewText;
            }
        }

        return null;
    }

    private static string BuildActionLabel(AiActionOption action)
    {
        string tone = GetInputValue(action.Inputs, "tone", "Neutral");
        string length = GetInputValue(action.Inputs, "length", "Same");
        bool preserveTerms = GetInputValue(action.Inputs, "preserve_terms", true);
        string preserveLabel = preserveTerms ? "Yes" : "No";
        return $"{action.Label}  Tone: {tone}  Length: {length}  Preserve terms: {preserveLabel}";
    }

    private static string GetInputValue(Dictionary<string, object?> inputs, string key, string defaultValue)
    {
        if (!inputs.TryGetValue(key, out object? value) || value is null)
        {
            return defaultValue;
        }

        return value.ToString() ?? defaultValue;
    }

    private static bool GetInputValue(Dictionary<string, object?> inputs, string key, bool defaultValue)
    {
        if (!inputs.TryGetValue(key, out object? value) || value is null)
        {
            return defaultValue;
        }

        if (value is bool boolValue)
        {
            return boolValue;
        }

        return bool.TryParse(value.ToString(), out bool parsed) ? parsed : defaultValue;
    }

    private string? GetImageDataUrl(AiProposal proposal)
    {
        for (int index = 0; index < proposal.ArtifactIds.Count; index++)
        {
            AiArtifact? artifact = ArtifactStore.Get(proposal.ArtifactIds[index]);
            if (artifact is null || artifact.Modality != AiModality.Image)
            {
                continue;
            }

            if (artifact.Metadata is not null && artifact.Metadata.TryGetValue("dataUrl", out object? value))
            {
                return value?.ToString();
            }

            if (artifact.BinaryContent is not null)
            {
                string base64 = Convert.ToBase64String(artifact.BinaryContent);
                return $"data:{artifact.MimeType};base64,{base64}";
            }
        }

        return null;
    }

    private string? GetCoverImageDataUrl(Guid sectionId)
    {
        Guid? previewId = _pendingAiProposal is not null ? AiAttachmentStore.GetCoverImageId(sectionId) : null;
        if (previewId is not null)
        {
            AiArtifact? previewArtifact = ArtifactStore.Get(previewId.Value);
            if (previewArtifact is not null)
            {
                if (previewArtifact.Metadata is not null && previewArtifact.Metadata.TryGetValue("dataUrl", out object? value))
                {
                    return value?.ToString();
                }

                if (previewArtifact.BinaryContent is not null)
                {
                    string base64 = Convert.ToBase64String(previewArtifact.BinaryContent);
                    return $"data:{previewArtifact.MimeType};base64,{base64}";
                }
            }
        }

        Guid? coverId = _state.Document.CoverImageId;
        if (coverId is null)
        {
            return null;
        }

        for (int index = 0; index < _state.Document.Artifacts.Count; index++)
        {
            DocumentArtifact artifact = _state.Document.Artifacts[index];
            if (artifact.ArtifactId != coverId.Value)
            {
                continue;
            }

            if (!string.IsNullOrWhiteSpace(artifact.DataUrl))
            {
                return artifact.DataUrl;
            }

            if (!string.IsNullOrWhiteSpace(artifact.Base64Data))
            {
                return $"data:{artifact.MimeType};base64,{artifact.Base64Data}";
            }
        }

        return null;
    }

    private Task OnSimulateAiEdit()
    {
        return ExecuteSafeAsync("OnSimulateAiEdit", () =>
        {
            if (!HostEnvironment.IsDevelopment())
            {
                return Task.CompletedTask;
            }

            string plainText = PlainTextMapper.ToPlainText(_activeSectionContent);
            int length = plainText.Length;
            if (length == 0)
            {
                return Task.CompletedTask;
            }

            TextRange range = _currentSelectionRange is { Length: > 0 }
                ? _currentSelectionRange
                : new TextRange(0, length);

            string reason = "TEST: Simulated AI edit";
            _commandProcessor.Execute(new SimulatedAiEditCommand(_activeSectionId, range, reason));
            return InvokeCommandAsync("focusEditor");
        });
    }

    private void OnContextMenuKeyDown(KeyboardEventArgs args)
    {
        if (string.Equals(args.Key, "Escape", StringComparison.Ordinal))
        {
            CloseContextMenu();
        }
    }

    private Task HandleDocumentChangedAsync()
    {
        return ExecuteSafeAsync("HandleDocumentChangedAsync", async () =>
        {
            if (_disposed)
            {
                return;
            }

            RefreshFromDocument(_state.Document);
            if (_pendingAiProposal is not null)
            {
                _pendingAiProposal = null;
            }
            await UpdateAiDecorationsAsync();

            if (_suppressDirtyUpdate)
            {
                _suppressDirtyUpdate = false;
            }
            else
            {
                _isDirty = true;
            }

            bool shouldSyncEditor = !_skipNextEditorSync;
            _skipNextEditorSync = false;

            if (_editorRef is not null && shouldSyncEditor)
            {
                _suppressEditorEvent = true;
                try
                {
                    await _editorRef.SetContentAsync(_activeSectionContent);
                }
                finally
                {
                    _suppressEditorEvent = false;
                }
            }

            await InvokeAsync(StateHasChanged);
        });
    }

    private void RefreshFromDocument(Document document)
    {
        _previewSections.Clear();
        _orderedSections.Clear();
        int wordCount = 0;
        for (int chapterIndex = 0; chapterIndex < document.Chapters.Count; chapterIndex++)
        {
            Chapter chapter = document.Chapters[chapterIndex];
            for (int sectionIndex = 0; sectionIndex < chapter.Sections.Count; sectionIndex++)
            {
                Section section = chapter.Sections[sectionIndex];
                _previewSections.Add(section.Content.Value ?? string.Empty);
                wordCount += CountWords(section.Content.Value);
            }
        }

        Chapter? primaryChapter = document.Chapters.Count > 0 ? document.Chapters[0] : null;
        if (primaryChapter is not null)
        {
            _orderedSections.AddRange(primaryChapter.Sections.OrderBy(section => section.Order));
        }

        Section activeSection = FindSection(document, _activeSectionId);
        _activeSectionContent = activeSection.Content.Value ?? string.Empty;
        UpdateReadingMetrics(wordCount);
    }

    private static int CountWords(string? html)
    {
        if (string.IsNullOrWhiteSpace(html))
        {
            return 0;
        }

        string decoded = ExtractPlainText(html);
        MatchCollection matches = Regex.Matches(decoded, @"\b[\p{L}\p{N}']+\b");
        return matches.Count;
    }

    private static int CountCharacters(string? html)
    {
        if (string.IsNullOrWhiteSpace(html))
        {
            return 0;
        }

        string decoded = ExtractPlainText(html);
        return decoded.Length;
    }

    private static string ExtractPlainText(string html)
    {
        return PlainTextMapper.ToPlainText(html);
    }

    private void UpdateSelectionRange(int start, int end)
    {
        if (start < 0 || end < 0)
        {
            _currentSelectionRange = null;
            return;
        }

        string plainText = PlainTextMapper.ToPlainText(_activeSectionContent);
        int maxLength = plainText.Length;
        int normalizedStart = Math.Clamp(Math.Min(start, end), 0, maxLength);
        int normalizedEnd = Math.Clamp(Math.Max(start, end), 0, maxLength);
        _currentSelectionRange = new TextRange(normalizedStart, normalizedEnd - normalizedStart);
    }

    private void UpdateAiContextMenuState()
    {
        _hasAiEditsAtSelection = false;
        _hasMultipleAiEditsInSection = false;
        _aiRollbackGroupId = null;

        if (_currentSelectionRange is null)
        {
            return;
        }

        string plainText = PlainTextMapper.ToPlainText(_activeSectionContent);
        AiEditSelectionInfo info = _commandProcessor.GetAiEditSelectionInfo(
            _activeSectionId,
            _currentSelectionRange,
            plainText.Length);

        _hasAiEditsAtSelection = info.HasIntersection;
        _hasMultipleAiEditsInSection = info.HasMultipleGroups;
        _aiRollbackGroupId = info.GroupId;
    }

    private async Task UpdateAiDecorationsAsync()
    {
        if (_editorInstance is null)
        {
            return;
        }

        string plainText = PlainTextMapper.ToPlainText(_activeSectionContent);
        IReadOnlyList<AiEditRangeInfo> ranges = _commandProcessor.GetAiEditRanges(_activeSectionId, plainText.Length);
        List<AiEditDecoration> decorations = new(ranges.Count);

        for (int index = 0; index < ranges.Count; index++)
        {
            TextRange range = ranges[index].Range;
            int start = Math.Clamp(range.Start, 0, plainText.Length);
            int end = Math.Clamp(range.Start + range.Length, 0, plainText.Length);
            if (end <= start)
            {
                continue;
            }

            bool isActive = _currentSelectionRange is not null
                && RangesIntersect(_currentSelectionRange, new TextRange(start, end - start));

            decorations.Add(new AiEditDecoration(start, end, isActive));
        }

        await JSRuntime.InvokeVoidAsync("tiptapEditor.setAiDecorations", _editorInstance, decorations);
    }

    private static bool RangesIntersect(TextRange selection, TextRange target)
    {
        if (selection.Length == 0)
        {
            int point = selection.Start;
            return point >= target.Start && point <= target.Start + target.Length;
        }

        int selectionEnd = selection.Start + selection.Length;
        int targetEnd = target.Start + target.Length;
        return selection.Start < targetEnd && target.Start < selectionEnd;
    }

    private void UpdateReadingMetrics(int wordCount)
    {
        _wordCount = wordCount;
        if (wordCount == 0)
        {
            _readingTime = "0 min read";
            return;
        }

        int minutes = Math.Max(1, (int)Math.Ceiling(wordCount / 220.0));
        _readingTime = $"{minutes} min read";
    }

    private static Section FindSection(Document document, Guid sectionId)
    {
        for (int chapterIndex = 0; chapterIndex < document.Chapters.Count; chapterIndex++)
        {
            Chapter chapter = document.Chapters[chapterIndex];
            for (int sectionIndex = 0; sectionIndex < chapter.Sections.Count; sectionIndex++)
            {
                Section section = chapter.Sections[sectionIndex];
                if (section.SectionId == sectionId)
                {
                    return section;
                }
            }
        }

        throw new InvalidOperationException($"Section {sectionId} was not found.");
    }

    private static Document CreateSampleDocument()
    {
        DateTime now = DateTime.UtcNow;

        return new Document
        {
            Metadata = new DocumentMetadata
            {
                Title = "Sample Draft",
                Author = "Demo",
                Language = "en",
                Tags = new List<string> { "demo" },
                CreatedUtc = now,
                ModifiedUtc = now
            },
            Settings = new DocumentSettings
            {
                DefaultFont = "Georgia",
                DefaultFontSize = 12,
                PageSize = "Letter",
                LineSpacing = 1.5
            },
            Chapters = new List<Chapter>
            {
                new Chapter
                {
                    Order = 0,
                    Title = "Draft",
                    Sections = new List<Section>
                    {
                        new Section
                        {
                            Order = 0,
                            Title = "Opening Scene",
                            Content = new SectionContent
                            {
                                Format = "html",
                                Value = "<h1>Opening Scene</h1><p>The storm rolled in just after dusk, wrapping the town in a soft gray hush.</p>"
                            },
                            Stats = new SectionStats(),
                            Flags = new SectionFlags(),
                            AI = new SectionAIInfo(),
                            CreatedUtc = now,
                            ModifiedUtc = now
                        },
                        new Section
                        {
                            Order = 1,
                            Title = "Chapter One",
                            Content = new SectionContent
                            {
                                Format = "html",
                                Value = "<h2>Chapter One</h2><p>Eva traced the map with her finger, pausing at the edge of the inked coastline.</p>"
                            },
                            Stats = new SectionStats(),
                            Flags = new SectionFlags(),
                            AI = new SectionAIInfo(),
                            CreatedUtc = now,
                            ModifiedUtc = now
                        },
                        new Section
                        {
                            Order = 2,
                            Title = "Chapter Two",
                            Content = new SectionContent
                            {
                                Format = "html",
                                Value = "<h2>Chapter Two</h2><p>By morning, the docks were empty, save for a single lantern swaying against the tide.</p>"
                            },
                            Stats = new SectionStats(),
                            Flags = new SectionFlags(),
                            AI = new SectionAIInfo(),
                            CreatedUtc = now,
                            ModifiedUtc = now
                        }
                    }
                }
            }
        };
    }

    private Task OnEditorReady(IJSObjectReference editor)
    {
        return ExecuteSafeAsync("OnEditorReady", async () =>
        {
            _editorInstance = editor;
            await EnsureCommandsModuleAsync();
        });
    }

    private Task OnBoldRequested() => ExecuteSafeAsync("OnBoldRequested", () => InvokeCommandAsync("toggleBold"));

    private Task OnItalicRequested() => ExecuteSafeAsync("OnItalicRequested", () => InvokeCommandAsync("toggleItalic"));

    private Task OnStrikeRequested() => ExecuteSafeAsync("OnStrikeRequested", () => InvokeCommandAsync("toggleStrike"));

    private Task OnCodeRequested() => ExecuteSafeAsync("OnCodeRequested", () => InvokeCommandAsync("toggleCode"));

    private Task OnParagraphRequested() => ExecuteSafeAsync("OnParagraphRequested", () => InvokeCommandAsync("setParagraph"));

    private Task OnHeadingRequested(int level) => ExecuteSafeAsync("OnHeadingRequested", () => InvokeCommandAsync("toggleHeading", level));

    private Task OnBlockquoteRequested() => ExecuteSafeAsync("OnBlockquoteRequested", () => InvokeCommandAsync("toggleBlockquote"));

    private Task OnHorizontalRuleRequested() => ExecuteSafeAsync("OnHorizontalRuleRequested", () => InvokeCommandAsync("insertHorizontalRule"));

    private Task OnBulletListRequested() => ExecuteSafeAsync("OnBulletListRequested", () => InvokeCommandAsync("toggleBulletList"));

    private Task OnOrderedListRequested() => ExecuteSafeAsync("OnOrderedListRequested", () => InvokeCommandAsync("toggleOrderedList"));

    private async Task EnsureCommandsModuleAsync()
    {
        if (_commandsModule is null)
        {
            _commandsModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                "import",
                "/js/tiptap-commands.js");
        }
    }

    private async Task InvokeCommandAsync(string command, params object?[] extraArgs)
    {
        if (_editorInstance is null)
        {
            return;
        }

        await EnsureCommandsModuleAsync();
        if (_commandsModule is null)
        {
            return;
        }

        object?[] args = new object?[1 + extraArgs.Length];
        args[0] = _editorInstance;
        for (int i = 0; i < extraArgs.Length; i++)
        {
            args[i + 1] = extraArgs[i];
        }

        await _commandsModule.InvokeVoidAsync(command, args);

        if (!string.Equals(command, "focusEditor", StringComparison.Ordinal))
        {
            await _commandsModule.InvokeVoidAsync("focusEditor", _editorInstance);
        }
    }

    private Task OnSave()
    {
        return ExecuteSafeAsync("OnSave", async () =>
        {
            try
            {
                Document normalized = NormalizeDocumentForSave(_state.Document);
                DocumentStorage payload = new(normalized);
                string json = JsonSerializer.Serialize(payload);
                await JSRuntime.InvokeVoidAsync("localStorage.setItem", StorageKey, json);

                string documentKey = StoragePrefix + normalized.DocumentId;
                await JSRuntime.InvokeVoidAsync("localStorage.setItem", documentKey, json);
                await UpdateDocumentIndexAsync(normalized);
                _state.ReplaceDocument(normalized, notify: false);
                RefreshFromDocument(normalized);
                _lastSavedUtc = normalized.Metadata.ModifiedUtc;
                _isDirty = false;
                await InvokeAsync(StateHasChanged);
            }
            catch (JSException ex)
            {
                Logger.LogWarning(ex, "Local storage save failed.");
            }
        });
    }

    private Task LoadDocumentAsync()
    {
        return ExecuteSafeAsync("LoadDocumentAsync", async () =>
        {
            string? json = null;
            try
            {
                json = await JSRuntime.InvokeAsync<string>("localStorage.getItem", StorageKey);
            }
            catch (JSException ex)
            {
                Logger.LogWarning(ex, "Local storage read failed.");
                return;
            }

            if (string.IsNullOrWhiteSpace(json))
            {
                if (_savedDocuments.Count == 0)
                {
                    return;
                }

                DocumentIndexEntry latest = _savedDocuments[0];
                await LoadDocumentByIdAsync(latest.DocumentId.ToString());
                return;
            }

            DocumentStorage? payload = JsonSerializer.Deserialize<DocumentStorage>(json);
            if (payload?.Document is null)
            {
                return;
            }

            InitializeState(NormalizeDocumentForLoad(payload.Document));
            await SyncEditorAsync();
        });
    }

    private Task LoadDocumentByIdAsync(string documentId)
    {
        return ExecuteSafeAsync("LoadDocumentByIdAsync", async () =>
        {
            string key = StoragePrefix + documentId;
            string? json = null;
            try
            {
                json = await JSRuntime.InvokeAsync<string>("localStorage.getItem", key);
            }
            catch (JSException ex)
            {
                Logger.LogWarning(ex, "Local storage read failed.");
                return;
            }

            if (string.IsNullOrWhiteSpace(json))
            {
                return;
            }

            DocumentStorage? payload = JsonSerializer.Deserialize<DocumentStorage>(json);
            if (payload?.Document is null)
            {
                return;
            }

            InitializeState(NormalizeDocumentForLoad(payload.Document));
            await SyncEditorAsync();
        });
    }

    private Task LoadDocumentIndexAsync()
    {
        return ExecuteSafeAsync("LoadDocumentIndexAsync", async () =>
        {
            _savedDocuments.Clear();

            string? json = null;
            try
            {
                json = await JSRuntime.InvokeAsync<string>("localStorage.getItem", StorageIndexKey);
            }
            catch (JSException ex)
            {
                Logger.LogWarning(ex, "Local storage index read failed.");
                return;
            }

            if (string.IsNullOrWhiteSpace(json))
            {
                return;
            }

            List<DocumentIndexEntry>? entries = JsonSerializer.Deserialize<List<DocumentIndexEntry>>(json);
            if (entries is null)
            {
                return;
            }

            entries.Sort((a, b) => b.LastModifiedUtc.CompareTo(a.LastModifiedUtc));
            _savedDocuments.AddRange(entries);
        });
    }

    private Task UpdateDocumentIndexAsync(Document document)
    {
        return ExecuteSafeAsync("UpdateDocumentIndexAsync", async () =>
        {
            string title = string.IsNullOrWhiteSpace(document.Metadata.Title)
                ? "Untitled"
                : document.Metadata.Title;

            DocumentIndexEntry entry = new(document.DocumentId, title, document.Metadata.ModifiedUtc);

            int index = _savedDocuments.FindIndex(item => item.DocumentId == entry.DocumentId);
            if (index >= 0)
            {
                _savedDocuments[index] = entry;
            }
            else
            {
                _savedDocuments.Add(entry);
            }

            _savedDocuments.Sort((a, b) => b.LastModifiedUtc.CompareTo(a.LastModifiedUtc));
            string json = JsonSerializer.Serialize(_savedDocuments);

            try
            {
                await JSRuntime.InvokeVoidAsync("localStorage.setItem", StorageIndexKey, json);
            }
            catch (JSException ex)
            {
                Logger.LogWarning(ex, "Local storage index update failed.");
            }
        });
    }

    private Document NormalizeDocumentForSave(Document document)
    {
        Document normalized = NormalizeDocumentForLoad(document);
        DocumentMetadata updatedMetadata = normalized.Metadata with { ModifiedUtc = DateTime.UtcNow };
        return normalized with { Metadata = updatedMetadata };
    }

    private Document NormalizeDocumentForLoad(Document document)
    {
        string? title = document.Metadata.Title;
        if (string.IsNullOrWhiteSpace(title))
        {
            title = DeriveTitleFromDocument(document);
        }

        DocumentMetadata updatedMetadata = document.Metadata with
        {
            Title = title ?? document.Metadata.Title
        };

        List<Chapter> chapters = new();
        for (int chapterIndex = 0; chapterIndex < document.Chapters.Count; chapterIndex++)
        {
            Chapter chapter = document.Chapters[chapterIndex];
            List<Section> sections = new();
            for (int sectionIndex = 0; sectionIndex < chapter.Sections.Count; sectionIndex++)
            {
                Section section = chapter.Sections[sectionIndex];
                SectionStats stats = new()
                {
                    WordCount = CountWords(section.Content.Value),
                    CharacterCount = CountCharacters(section.Content.Value)
                };

                sections.Add(section with { Stats = stats });
            }

            chapters.Add(chapter with { Sections = sections });
        }

        return document with
        {
            Metadata = updatedMetadata,
            Chapters = chapters
        };
    }

    private static string? DeriveTitleFromDocument(Document document)
    {
        Regex headingRegex = new("<h[1-6][^>]*>(.*?)</h[1-6]>", RegexOptions.IgnoreCase | RegexOptions.Singleline);
        for (int chapterIndex = 0; chapterIndex < document.Chapters.Count; chapterIndex++)
        {
            Chapter chapter = document.Chapters[chapterIndex];
            for (int sectionIndex = 0; sectionIndex < chapter.Sections.Count; sectionIndex++)
            {
                Section section = chapter.Sections[sectionIndex];
                string html = section.Content.Value ?? string.Empty;
                Match match = headingRegex.Match(html);
                if (!match.Success)
                {
                    continue;
                }

                string plain = ExtractPlainText(match.Groups[1].Value);
                if (string.IsNullOrWhiteSpace(plain))
                {
                    continue;
                }

                plain = Regex.Replace(plain, @"\s+", " ").Trim();
                if (plain.Length > 60)
                {
                    plain = plain.Substring(0, 60).Trim();
                }

                return plain;
            }
        }

        return null;
    }

    private void InitializeState(Document document)
    {
        _state.OnChanged -= _onChangedHandler;
        _state = new DocumentState(document);
        _commandProcessor = new CommandProcessor(_state);
        _state.OnChanged += _onChangedHandler;

        if (document.Chapters.Count > 0 && document.Chapters[0].Sections.Count > 0)
        {
            _activeSectionId = document.Chapters[0].Sections[0].SectionId;
        }

        RefreshFromDocument(_state.Document);
        _lastSavedUtc = _state.Document.Metadata.ModifiedUtc;
        _isDirty = false;
    }

    private async Task SyncEditorAsync()
    {
        if (_editorRef is null)
        {
            return;
        }

        _suppressEditorEvent = true;
        try
        {
            await _editorRef.SetContentAsync(_activeSectionContent);
        }
        finally
        {
            _suppressEditorEvent = false;
        }
    }

    private string GetDirtyLabel() => _isDirty ? "Unsaved changes" : "All changes saved";

    private string GetDirtyClass() => _isDirty ? "dirty-indicator" : "clean-indicator";

    private string GetLastSavedLabel()
    {
        if (_lastSavedUtc == default)
        {
            return "Not saved yet";
        }

        TimeSpan delta = DateTime.UtcNow - _lastSavedUtc;
        if (delta < TimeSpan.FromMinutes(1))
        {
            return "Last saved just now";
        }

        if (delta < TimeSpan.FromHours(1))
        {
            int minutes = Math.Max(1, (int)Math.Round(delta.TotalMinutes));
            return $"Last saved {minutes} min ago";
        }

        if (delta < TimeSpan.FromDays(1))
        {
            int hours = Math.Max(1, (int)Math.Round(delta.TotalHours));
            return $"Last saved {hours} hr ago";
        }

        int days = Math.Max(1, (int)Math.Round(delta.TotalDays));
        return $"Last saved {days} day{(days == 1 ? string.Empty : "s")} ago";
    }

    private async Task ExecuteSafeAsync(string operation, Func<Task> action)
    {
        try
        {
            await action();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Home {Operation} failed.", operation);
        }
    }

    private void ExecuteSafe(string operation, Action action)
    {
        try
        {
            action();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Home {Operation} failed.", operation);
        }
    }

    public void Dispose()
    {
        _state.OnChanged -= _onChangedHandler;
        CancelAiStream();
    }

    public async ValueTask DisposeAsync()
    {
        if (_disposed)
        {
            return;
        }

        _disposed = true;

        if (_commandsModule is not null)
        {
            try
            {
                await _commandsModule.DisposeAsync();
            }
            catch (ObjectDisposedException)
            {
            }
            catch (JSDisconnectedException)
            {
            }
            finally
            {
                _commandsModule = null;
            }
        }
    }

    private sealed record DocumentStorage(Document Document);

    private sealed record DocumentIndexEntry(Guid DocumentId, string Title, DateTime LastModifiedUtc);

    private sealed record AiEditDecoration(int Start, int End, bool IsActive);

    private sealed record AiActionOption(
        string Label,
        string Instruction,
        AiActionScope Scope,
        Dictionary<string, object?> Inputs);
}
