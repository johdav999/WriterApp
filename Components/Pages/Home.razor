@page "/"
@rendermode Microsoft.AspNetCore.Components.Web.RenderMode.InteractiveServer
@using System
@using System.Collections.Generic
@using System.Globalization
@using System.Linq
@using System.Net
@using System.Text.Json
@using System.Text.RegularExpressions
@using BlazorApp.Components.Editor
@using Microsoft.AspNetCore.Components
@using Microsoft.JSInterop
@using WriterApp.Application.Commands
@using WriterApp.Application.State
@using WriterApp.Domain.Documents
@implements IDisposable
@implements IAsyncDisposable
@inject IJSRuntime JSRuntime

<PageTitle>Writer</PageTitle>

<div class="editor-preview-layout">
    <div class="editor-pane">
        <div class="pane-header">
            <h2>Section Editor</h2>
            <div class="section-nav">
                <div class="section-nav-header">
                    <h3>Sections</h3>
                    <button type="button" @onclick="OnCreateSection">Add section</button>
                </div>
                <ul class="section-nav-list">
                    @foreach (Section section in _orderedSections)
                    {
                        <li class="section-nav-row">
                            <button type="button"
                                    class="section-nav-item @GetActiveSectionClass(section.SectionId)"
                                    @onclick="() => OnSectionSelected(section.SectionId)">
                                <span class="section-order">@GetSectionOrderLabel(section)</span>
                                <span class="section-title">@GetSectionTitle(section)</span>
                            </button>
                            <div class="section-nav-actions">
                                <button type="button" @onclick="() => OnMoveSectionUp(section.SectionId)" disabled="@IsFirstSection(section)">Up</button>
                                <button type="button" @onclick="() => OnMoveSectionDown(section.SectionId)" disabled="@IsLastSection(section)">Down</button>
                                <button type="button" @onclick="() => OnDeleteSection(section.SectionId)" disabled="@(_orderedSections.Count <= 1)">Delete</button>
                            </div>
                        </li>
                    }
                </ul>
            </div>
            <div class="editor-toolbar" role="toolbar" aria-label="Editor formatting">
                <div class="editor-toolbar-group" aria-label="Text emphasis">
                    <button type="button" class="@GetActiveClass(_formattingState.IsBold)" disabled="@(!_formattingState.CanBold)" @onclick="OnBoldRequested">Bold</button>
                    <button type="button" class="@GetActiveClass(_formattingState.IsItalic)" disabled="@(!_formattingState.CanItalic)" @onclick="OnItalicRequested">Italic</button>
                    <button type="button" class="@GetActiveClass(_formattingState.IsStrike)" disabled="@(!_formattingState.CanStrike)" @onclick="OnStrikeRequested">Strike</button>
                    <button type="button" class="@GetActiveClass(_formattingState.IsCode)" disabled="@(!_formattingState.CanCode)" @onclick="OnCodeRequested">Code</button>
                </div>
                <div class="editor-toolbar-group" aria-label="Structure">
                    <button type="button" class="@GetActiveClass(_formattingState.BlockType == "paragraph")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="OnParagraphRequested">Paragraph</button>
                    <button type="button" class="@GetActiveClass(_formattingState.BlockType == "heading:1")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="() => OnHeadingRequested(1)">H1</button>
                    <button type="button" class="@GetActiveClass(_formattingState.BlockType == "heading:2")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="() => OnHeadingRequested(2)">H2</button>
                    <button type="button" class="@GetActiveClass(_formattingState.BlockType == "heading:3")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="() => OnHeadingRequested(3)">H3</button>
                    <button type="button" class="@GetActiveClass(_formattingState.BlockType == "heading:4")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="() => OnHeadingRequested(4)">H4</button>
                    <button type="button" class="@GetActiveClass(_formattingState.BlockType == "heading:5")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="() => OnHeadingRequested(5)">H5</button>
                    <button type="button" class="@GetActiveClass(_formattingState.BlockType == "heading:6")" disabled="@(!_formattingState.CanApplyHeading)" @onclick="() => OnHeadingRequested(6)">H6</button>
                    <button type="button" disabled="@(!_formattingState.CanBlockquote)" @onclick="OnBlockquoteRequested">Blockquote</button>
                    <button type="button" disabled="@(!_formattingState.CanHorizontalRule)" @onclick="OnHorizontalRuleRequested">Horizontal rule</button>
                </div>
                <div class="editor-toolbar-group" aria-label="Lists">
                    <button type="button" disabled="@(!_formattingState.CanToggleList)" @onclick="OnBulletListRequested">Bullet list</button>
                    <button type="button" disabled="@(!_formattingState.CanToggleList)" @onclick="OnOrderedListRequested">Ordered list</button>
                </div>
                <div class="editor-toolbar-group" aria-label="Typography">
                    <label class="editor-toolbar-label" for="fontFamilySelect">Font</label>
                    <select id="fontFamilySelect" class="editor-toolbar-select" value="@_fontFamily" @onchange="OnFontFamilyChanged">
                        <option value="mixed" disabled>Mixed</option>
                        <option value="">Default</option>
                        <option value="Georgia">Georgia</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Arial">Arial</option>
                        <option value="Helvetica">Helvetica</option>
                        <option value="Courier New">Courier New</option>
                    </select>
                    <label class="editor-toolbar-label" for="fontSizeSelect">Text size</label>
                    <select id="fontSizeSelect" class="editor-toolbar-select" value="@_fontSize" @onchange="OnFontSizeChanged">
                        <option value="mixed" disabled>Mixed</option>
                        <option value="12">12px</option>
                        <option value="14">14px</option>
                        <option value="16">16px</option>
                        <option value="18">18px</option>
                        <option value="24">24px</option>
                        <option value="32">32px</option>
                    </select>
                </div>
            </div>
            <div class="editor-actions">
                <button type="button" @onclick="OnUndo" disabled="@(!_commandProcessor.CanUndo)">Undo</button>
                <button type="button" @onclick="OnRedo" disabled="@(!_commandProcessor.CanRedo)">Redo</button>
                <button type="button" @onclick="OnSave">Save</button>
                <select class="editor-toolbar-select" value="@_selectedDocumentId" @onchange="OnSelectedDocumentChanged">
                    <option value="">Load document...</option>
                    @foreach (DocumentIndexEntry entry in _savedDocuments)
                    {
                        <option value="@entry.DocumentId.ToString()">@entry.Title</option>
                    }
                </select>
                <button type="button" @onclick="OnLoadSelected" disabled="@string.IsNullOrWhiteSpace(_selectedDocumentId)">Load</button>
            </div>
            <div class="editor-status">
                <span>@_wordCount words</span>
                <span>@_readingTime</span>
                <span class="@GetDirtyClass()">@GetDirtyLabel()</span>
                <span>@GetLastSavedLabel()</span>
            </div>
        </div>
        <div class="pane-body editor-scroll">
            <SectionEditor @ref="_editorRef"
                           Content="@_activeSectionContent"
                           ContentChanged="OnSectionContentChanged"
                           EditorReady="OnEditorReady"
                           FormattingChanged="OnFormattingChanged"
                           OutlineChanged="OnOutlineChanged"
                           UndoRequested="OnUndo"
                           RedoRequested="OnRedo" />
        </div>
    </div>
    <div class="preview-pane">
        <div class="pane-header">
            <h2>Document Preview</h2>
        </div>
        <div class="pane-body preview-scroll">
            <div class="outline-panel">
                <h3>Outline</h3>
                @if (_outlineItems.Count == 0)
                {
                    <div class="outline-empty">No headings</div>
                }
                else
                {
                    <ul class="outline-list">
                        @foreach (OutlineItem item in _outlineItems)
                        {
                            <li>
                                <button type="button" class="outline-item level-@item.Level" @onclick="() => OnOutlineSelected(item)">
                                    @item.Text
                                </button>
                            </li>
                        }
                    </ul>
                }
            </div>
            <div class="document-preview">
                @if (_previewSections is not null)
                {
                    for (int i = 0; i < _previewSections.Count; i++)
                    {
                        string html = _previewSections[i] ?? string.Empty;
                        <section class="document-section">
                            @((MarkupString)html)
                        </section>
                    }
                }
            </div>
        </div>
    </div>
</div>

<style>
    .editor-preview-layout {
        display: flex;
        gap: 32px;
        align-items: flex-start;
        padding: 24px;
    }

    .editor-pane,
    .preview-pane {
        flex: 1 1 0;
        min-width: 320px;
    }

    .editor-pane h2,
    .preview-pane h2 {
        margin-top: 0;
        font-size: 1.1rem;
        letter-spacing: 0.02em;
    }

    .pane-header {
        display: flex;
        flex-direction: column;
        gap: 12px;
        padding-bottom: 12px;
        border-bottom: 1px solid #ececec;
        position: sticky;
        top: 0;
        background: #fff;
        z-index: 2;
    }

    .pane-header h2 {
        margin: 0;
    }

    .pane-body {
        padding-top: 12px;
        max-height: 70vh;
        overflow: auto;
    }

    .editor-toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
    }

    .section-nav {
        border: 1px solid #ececec;
        border-radius: 6px;
        padding: 10px;
        background: #fafafa;
    }

    .section-nav-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
    }

    .section-nav-header h3 {
        margin: 0;
        font-size: 1rem;
    }

    .section-nav-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        gap: 6px;
    }

    .section-nav-row {
        display: flex;
        align-items: center;
        gap: 6px;
    }

    .section-nav-item {
        flex: 1;
        display: flex;
        align-items: center;
        gap: 8px;
        text-align: left;
        padding: 6px 8px;
        border: 1px solid transparent;
        border-radius: 4px;
        background: #fff;
        cursor: pointer;
    }

    .section-nav-item.is-active {
        border-color: #9bb6f0;
        background: #e6eefc;
    }

    .section-order {
        font-size: 0.85rem;
        color: #6b6b6b;
        min-width: 24px;
    }

    .section-title {
        font-size: 0.95rem;
    }

    .section-nav-actions {
        display: flex;
        gap: 4px;
    }

    .editor-toolbar-group {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        padding-right: 10px;
        border-right: 1px solid #e3e3e3;
    }

    .editor-toolbar-group:last-child {
        padding-right: 0;
        border-right: none;
    }

    .editor-toolbar-label {
        align-self: center;
        font-size: 0.9rem;
    }

    .editor-toolbar-select {
        padding: 6px 8px;
        border: 1px solid #d0d0d0;
        border-radius: 4px;
        background: #fff;
        cursor: pointer;
    }

    .editor-actions {
        display: flex;
        gap: 8px;
        margin: 0;
    }

    .editor-status {
        display: flex;
        gap: 12px;
        font-size: 0.9rem;
        color: #5b5b5b;
    }

    .editor-actions button,
    .editor-toolbar button {
        padding: 6px 12px;
        border: 1px solid #d0d0d0;
        border-radius: 4px;
        background: #f8f8f8;
        cursor: pointer;
    }

    .section-nav-actions button,
    .section-nav-header button {
        padding: 4px 8px;
        border: 1px solid #d0d0d0;
        border-radius: 4px;
        background: #f8f8f8;
        cursor: pointer;
    }

    .section-nav-actions button:disabled,
    .section-nav-header button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .editor-actions select {
        padding: 6px 8px;
        border: 1px solid #d0d0d0;
        border-radius: 4px;
        background: #fff;
    }

    .editor-actions button:active,
    .editor-toolbar button:active {
        transform: translateY(1px);
    }

    .editor-toolbar button.is-active {
        background: #e6eefc;
        border-color: #9bb6f0;
    }

    .editor-toolbar button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .dirty-indicator {
        font-weight: 600;
        color: #b45309;
    }

    .clean-indicator {
        color: #4b5563;
    }

    .editor-pane .ProseMirror {
        min-height: 320px;
        padding: 12px;
        border: 1px solid #d9d9d9;
        border-radius: 6px;
        background: #fff;
    }

    .document-preview {
        max-width: 760px;
        margin: 0 auto;
        padding: 24px 28px;
        line-height: 1.6;
        font-family: "Georgia", "Times New Roman", serif;
        background: #fff;
        color: #1e1e1e;
        border: 1px solid #e2e2e2;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.06);
    }

    .document-section {
        margin-bottom: 28px;
        padding-bottom: 8px;
        border-bottom: 1px solid #f0f0f0;
    }

    .document-section:last-child {
        border-bottom: none;
        margin-bottom: 0;
        padding-bottom: 0;
    }

    .outline-panel {
        margin-bottom: 16px;
        padding: 12px;
        border: 1px solid #ececec;
        border-radius: 6px;
        background: #fafafa;
    }

    .outline-panel h3 {
        margin: 0 0 8px 0;
        font-size: 1rem;
    }

    .outline-list {
        list-style: none;
        margin: 0;
        padding: 0;
    }

    .outline-item {
        display: block;
        width: 100%;
        text-align: left;
        padding: 4px 6px;
        border: 1px solid transparent;
        border-radius: 4px;
        background: transparent;
        cursor: pointer;
    }

    .outline-item:hover {
        background: #f0f3f8;
        border-color: #d7dbe2;
    }

    .outline-item.level-1 { padding-left: 4px; }
    .outline-item.level-2 { padding-left: 16px; }
    .outline-item.level-3 { padding-left: 28px; }
    .outline-item.level-4 { padding-left: 40px; }
    .outline-item.level-5 { padding-left: 52px; }
    .outline-item.level-6 { padding-left: 64px; }

    .outline-empty {
        font-size: 0.9rem;
        color: #7a7a7a;
    }

    @@media (max-width: 900px) {
        .editor-preview-layout {
            flex-direction: column;
        }

        .pane-body {
            max-height: none;
        }
    }
</style>

@code {
    private DocumentState _state;
    private CommandProcessor _commandProcessor;
    private readonly Action _onChangedHandler;
    private readonly List<string> _previewSections = new();
    private readonly List<OutlineItem> _outlineItems = new();
    private readonly List<Section> _orderedSections = new();
    private SectionEditor? _editorRef;
    private Guid _activeSectionId;
    private string _activeSectionContent = string.Empty;
    private bool _suppressEditorEvent;
    private bool _skipNextEditorSync;
    private IJSObjectReference? _editorInstance;
    private IJSObjectReference? _commandsModule;
    private bool _disposed;
    private string _fontSize = "16";
    private string _fontFamily = string.Empty;
    private EditorFormattingState _formattingState = new()
    {
        CanBold = true,
        CanItalic = true,
        CanStrike = true,
        CanCode = true,
        CanApplyHeading = true,
        CanToggleList = true,
        CanBlockquote = true,
        CanHorizontalRule = true
    };
    private bool _loadedFromStorage;
    private int _wordCount;
    private string _readingTime = "0 min read";
    private string _selectedDocumentId = string.Empty;
    private readonly List<DocumentIndexEntry> _savedDocuments = new();
    private bool _isDirty;
    private DateTime _lastSavedUtc;
    private bool _suppressDirtyUpdate;

    private const string StorageKey = "writerapp.document";
    private const string StorageIndexKey = "writerapp.document.index";
    private const string StoragePrefix = "writerapp.document.";

    public Home()
    {
        Document document = CreateSampleDocument();
        _state = new DocumentState(document);
        _commandProcessor = new CommandProcessor(_state);
        _onChangedHandler = () => _ = HandleDocumentChangedAsync();
        _state.OnChanged += _onChangedHandler;

        if (document.Chapters.Count > 0 && document.Chapters[0].Sections.Count > 0)
        {
            _activeSectionId = document.Chapters[0].Sections[0].SectionId;
        }

        _lastSavedUtc = document.Metadata.ModifiedUtc;
    }

    protected override void OnInitialized()
    {
        RefreshFromDocument(_state.Document);
        _lastSavedUtc = _state.Document.Metadata.ModifiedUtc;
        _isDirty = false;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender || _loadedFromStorage)
        {
            return;
        }

        _loadedFromStorage = true;
        await LoadDocumentIndexAsync();
        await LoadDocumentAsync();
    }

    private Task OnSectionContentChanged(string html)
    {
        if (_suppressEditorEvent)
        {
            return Task.CompletedTask;
        }

        string content = html ?? string.Empty;
        Section section = FindSection(_state.Document, _activeSectionId);
        if (string.Equals(section.Content.Value, content, StringComparison.Ordinal))
        {
            return Task.CompletedTask;
        }

        _skipNextEditorSync = true;
        _commandProcessor.Execute(new UpdateSectionContentCommand(_activeSectionId, content));
        return Task.CompletedTask;
    }

    private Task OnUndo()
    {
        if (_commandProcessor.CanUndo)
        {
            _commandProcessor.Undo();
            return InvokeCommandAsync("focusEditor");
        }

        return Task.CompletedTask;
    }

    private Task OnRedo()
    {
        if (_commandProcessor.CanRedo)
        {
            _commandProcessor.Redo();
            return InvokeCommandAsync("focusEditor");
        }

        return Task.CompletedTask;
    }

    private async Task OnFontSizeChanged(ChangeEventArgs args)
    {
        if (args.Value is null)
        {
            return;
        }

        string? value = args.Value.ToString();
        if (string.Equals(value, "mixed", StringComparison.Ordinal))
        {
            return;
        }

        if (int.TryParse(value, out int size))
        {
            _fontSize = size.ToString(CultureInfo.InvariantCulture);
            await InvokeCommandAsync("setFontSize", size);
        }
    }

    private async Task OnFontFamilyChanged(ChangeEventArgs args)
    {
        string? family = args.Value?.ToString();
        _fontFamily = family ?? string.Empty;

        if (string.Equals(_fontFamily, "mixed", StringComparison.Ordinal))
        {
            return;
        }

        if (string.IsNullOrWhiteSpace(_fontFamily))
        {
            await InvokeCommandAsync("clearFontFamily");
            return;
        }

        await InvokeCommandAsync("setFontFamily", _fontFamily);
    }

    private void OnSelectedDocumentChanged(ChangeEventArgs args)
    {
        _selectedDocumentId = args.Value?.ToString() ?? string.Empty;
    }

    private async Task OnLoadSelected()
    {
        if (string.IsNullOrWhiteSpace(_selectedDocumentId))
        {
            return;
        }

        await LoadDocumentByIdAsync(_selectedDocumentId);
    }

    private async Task OnSectionSelected(Guid sectionId)
    {
        if (sectionId == _activeSectionId)
        {
            return;
        }

        _commandProcessor.ClearHistory();
        _activeSectionId = sectionId;
        _skipNextEditorSync = false;
        _suppressDirtyUpdate = true;
        _state.NotifyChanged();
        await InvokeCommandAsync("focusEditor");
    }

    private void OnMoveSectionUp(Guid sectionId)
    {
        MoveSection(sectionId, -1);
    }

    private void OnMoveSectionDown(Guid sectionId)
    {
        MoveSection(sectionId, 1);
    }

    private async Task OnCreateSection()
    {
        Chapter chapter = GetPrimaryChapter();
        List<Section> ordered = _orderedSections.Count > 0
            ? new List<Section>(_orderedSections)
            : chapter.Sections.OrderBy(section => section.Order).ToList();

        int insertIndex = ordered.FindIndex(section => section.SectionId == _activeSectionId);
        if (insertIndex < 0)
        {
            insertIndex = ordered.Count - 1;
        }

        Section newSection = new()
        {
            SectionId = Guid.NewGuid(),
            Order = insertIndex + 1,
            Title = string.Empty,
            Content = new SectionContent { Format = "html", Value = "<p></p>" },
            Stats = new SectionStats(),
            Flags = new SectionFlags(),
            AI = new SectionAIInfo(),
            CreatedUtc = DateTime.UtcNow,
            ModifiedUtc = DateTime.UtcNow
        };

        ordered.Insert(insertIndex + 1, newSection);
        chapter.Sections.Add(newSection);
        ApplySectionOrdering(ordered, chapter);

        _activeSectionId = newSection.SectionId;
        _commandProcessor.ClearHistory();
        _state.NotifyChanged();
        await InvokeCommandAsync("focusEditor");
    }

    private async Task OnDeleteSection(Guid sectionId)
    {
        if (_orderedSections.Count <= 1)
        {
            return;
        }

        bool confirmed = await JSRuntime.InvokeAsync<bool>("confirm", "Delete this section?");
        if (!confirmed)
        {
            return;
        }

        Chapter chapter = GetPrimaryChapter();
        List<Section> ordered = _orderedSections.Count > 0
            ? new List<Section>(_orderedSections)
            : chapter.Sections.OrderBy(section => section.Order).ToList();

        int removeIndex = ordered.FindIndex(section => section.SectionId == sectionId);
        if (removeIndex < 0)
        {
            return;
        }

        ordered.RemoveAt(removeIndex);
        chapter.Sections.RemoveAll(section => section.SectionId == sectionId);
        ApplySectionOrdering(ordered, chapter);

        if (sectionId == _activeSectionId)
        {
            int nextIndex = Math.Min(removeIndex, ordered.Count - 1);
            _activeSectionId = ordered[nextIndex].SectionId;
        }

        _commandProcessor.ClearHistory();
        _state.NotifyChanged();
        await InvokeCommandAsync("focusEditor");
    }

    private void MoveSection(Guid sectionId, int direction)
    {
        if (_orderedSections.Count <= 1 || direction == 0)
        {
            return;
        }

        Chapter chapter = GetPrimaryChapter();
        List<Section> ordered = _orderedSections.Count > 0
            ? new List<Section>(_orderedSections)
            : chapter.Sections.OrderBy(section => section.Order).ToList();

        int index = ordered.FindIndex(section => section.SectionId == sectionId);
        int targetIndex = index + direction;
        if (index < 0 || targetIndex < 0 || targetIndex >= ordered.Count)
        {
            return;
        }

        Section section = ordered[index];
        ordered.RemoveAt(index);
        ordered.Insert(targetIndex, section);
        ApplySectionOrdering(ordered, chapter);
        _state.NotifyChanged();
    }

    private Chapter GetPrimaryChapter()
    {
        if (_state.Document.Chapters.Count == 0)
        {
            Chapter chapter = new() { Order = 0, Title = "Draft" };
            _state.Document.Chapters.Add(chapter);
            return chapter;
        }

        return _state.Document.Chapters[0];
    }

    private void ApplySectionOrdering(List<Section> ordered, Chapter chapter)
    {
        Dictionary<Guid, Section> updates = new();
        for (int i = 0; i < ordered.Count; i++)
        {
            Section updated = ordered[i] with { Order = i };
            updates[updated.SectionId] = updated;
        }

        for (int i = 0; i < chapter.Sections.Count; i++)
        {
            Section section = chapter.Sections[i];
            if (updates.TryGetValue(section.SectionId, out Section updated))
            {
                chapter.Sections[i] = updated;
            }
        }
    }

    private bool IsFirstSection(Section section) => _orderedSections.Count == 0 || _orderedSections[0].SectionId == section.SectionId;

    private bool IsLastSection(Section section) => _orderedSections.Count == 0 || _orderedSections[^1].SectionId == section.SectionId;

    private string GetActiveSectionClass(Guid sectionId) => sectionId == _activeSectionId ? "is-active" : string.Empty;

    private string GetSectionOrderLabel(Section section) => (section.Order + 1).ToString(CultureInfo.InvariantCulture);

    private string GetSectionTitle(Section section)
    {
        if (!string.IsNullOrWhiteSpace(section.Title))
        {
            return section.Title;
        }

        string? derived = DeriveTitleFromSection(section.Content.Value);
        return string.IsNullOrWhiteSpace(derived) ? "Untitled section" : derived;
    }

    private static string? DeriveTitleFromSection(string? html)
    {
        if (string.IsNullOrWhiteSpace(html))
        {
            return null;
        }

        Match match = Regex.Match(html, "<h[1-6][^>]*>(.*?)</h[1-6]>", RegexOptions.IgnoreCase | RegexOptions.Singleline);
        if (!match.Success)
        {
            return null;
        }

        string plain = ExtractPlainText(match.Groups[1].Value);
        if (string.IsNullOrWhiteSpace(plain))
        {
            return null;
        }

        plain = Regex.Replace(plain, @"\s+", " ").Trim();
        if (plain.Length > 60)
        {
            plain = plain.Substring(0, 60).Trim();
        }

        return plain;
    }

    private Task OnOutlineChanged(List<OutlineItem> outline)
    {
        _outlineItems.Clear();
        if (outline is not null)
        {
            _outlineItems.AddRange(outline);
        }

        return InvokeAsync(StateHasChanged);
    }

    private Task OnOutlineSelected(OutlineItem item)
    {
        if (item is null)
        {
            return Task.CompletedTask;
        }

        return InvokeCommandAsync("scrollToPosition", item.Position);
    }

    private Task OnFormattingChanged(EditorFormattingState state)
    {
        _formattingState = state ?? new EditorFormattingState();
        _fontFamily = _formattingState.FontFamily is null
            ? "mixed"
            : string.IsNullOrWhiteSpace(_formattingState.FontFamily) ? string.Empty : _formattingState.FontFamily;
        _fontSize = _formattingState.FontSize is null
            ? "mixed"
            : string.IsNullOrWhiteSpace(_formattingState.FontSize) ? "16" : _formattingState.FontSize;

        return InvokeAsync(StateHasChanged);
    }

    private static string GetActiveClass(bool isActive) => isActive ? "is-active" : string.Empty;

    private async Task HandleDocumentChangedAsync()
    {
        RefreshFromDocument(_state.Document);

        if (_suppressDirtyUpdate)
        {
            _suppressDirtyUpdate = false;
        }
        else
        {
            _isDirty = true;
        }

        bool shouldSyncEditor = !_skipNextEditorSync;
        _skipNextEditorSync = false;

        if (_editorRef is not null && shouldSyncEditor)
        {
            _suppressEditorEvent = true;
            try
            {
                await _editorRef.SetContentAsync(_activeSectionContent);
            }
            finally
            {
                _suppressEditorEvent = false;
            }
        }

        await InvokeAsync(StateHasChanged);
    }

    private void RefreshFromDocument(Document document)
    {
        _previewSections.Clear();
        _orderedSections.Clear();
        int wordCount = 0;
        for (int chapterIndex = 0; chapterIndex < document.Chapters.Count; chapterIndex++)
        {
            Chapter chapter = document.Chapters[chapterIndex];
            for (int sectionIndex = 0; sectionIndex < chapter.Sections.Count; sectionIndex++)
            {
                Section section = chapter.Sections[sectionIndex];
                _previewSections.Add(section.Content.Value ?? string.Empty);
                wordCount += CountWords(section.Content.Value);
            }
        }

        Chapter? primaryChapter = document.Chapters.Count > 0 ? document.Chapters[0] : null;
        if (primaryChapter is not null)
        {
            _orderedSections.AddRange(primaryChapter.Sections.OrderBy(section => section.Order));
        }

        Section activeSection = FindSection(document, _activeSectionId);
        _activeSectionContent = activeSection.Content.Value ?? string.Empty;
        UpdateReadingMetrics(wordCount);
    }

    private static int CountWords(string? html)
    {
        if (string.IsNullOrWhiteSpace(html))
        {
            return 0;
        }

        string decoded = ExtractPlainText(html);
        MatchCollection matches = Regex.Matches(decoded, @"\b[\p{L}\p{N}']+\b");
        return matches.Count;
    }

    private static int CountCharacters(string? html)
    {
        if (string.IsNullOrWhiteSpace(html))
        {
            return 0;
        }

        string decoded = ExtractPlainText(html);
        return decoded.Length;
    }

    private static string ExtractPlainText(string html)
    {
        string noTags = Regex.Replace(html, "<[^>]+>", " ");
        string decoded = WebUtility.HtmlDecode(noTags);
        return decoded.Trim();
    }

    private void UpdateReadingMetrics(int wordCount)
    {
        _wordCount = wordCount;
        if (wordCount == 0)
        {
            _readingTime = "0 min read";
            return;
        }

        int minutes = Math.Max(1, (int)Math.Ceiling(wordCount / 220.0));
        _readingTime = $"{minutes} min read";
    }

    private static Section FindSection(Document document, Guid sectionId)
    {
        for (int chapterIndex = 0; chapterIndex < document.Chapters.Count; chapterIndex++)
        {
            Chapter chapter = document.Chapters[chapterIndex];
            for (int sectionIndex = 0; sectionIndex < chapter.Sections.Count; sectionIndex++)
            {
                Section section = chapter.Sections[sectionIndex];
                if (section.SectionId == sectionId)
                {
                    return section;
                }
            }
        }

        throw new InvalidOperationException($"Section {sectionId} was not found.");
    }

    private static Document CreateSampleDocument()
    {
        DateTime now = DateTime.UtcNow;

        return new Document
        {
            Metadata = new DocumentMetadata
            {
                Title = "Sample Draft",
                Author = "Demo",
                Language = "en",
                Tags = new List<string> { "demo" },
                CreatedUtc = now,
                ModifiedUtc = now
            },
            Settings = new DocumentSettings
            {
                DefaultFont = "Georgia",
                DefaultFontSize = 12,
                PageSize = "Letter",
                LineSpacing = 1.5
            },
            Chapters = new List<Chapter>
            {
                new Chapter
                {
                    Order = 0,
                    Title = "Draft",
                    Sections = new List<Section>
                    {
                        new Section
                        {
                            Order = 0,
                            Title = "Opening Scene",
                            Content = new SectionContent
                            {
                                Format = "html",
                                Value = "<h1>Opening Scene</h1><p>The storm rolled in just after dusk, wrapping the town in a soft gray hush.</p>"
                            },
                            Stats = new SectionStats(),
                            Flags = new SectionFlags(),
                            AI = new SectionAIInfo(),
                            CreatedUtc = now,
                            ModifiedUtc = now
                        },
                        new Section
                        {
                            Order = 1,
                            Title = "Chapter One",
                            Content = new SectionContent
                            {
                                Format = "html",
                                Value = "<h2>Chapter One</h2><p>Eva traced the map with her finger, pausing at the edge of the inked coastline.</p>"
                            },
                            Stats = new SectionStats(),
                            Flags = new SectionFlags(),
                            AI = new SectionAIInfo(),
                            CreatedUtc = now,
                            ModifiedUtc = now
                        },
                        new Section
                        {
                            Order = 2,
                            Title = "Chapter Two",
                            Content = new SectionContent
                            {
                                Format = "html",
                                Value = "<h2>Chapter Two</h2><p>By morning, the docks were empty, save for a single lantern swaying against the tide.</p>"
                            },
                            Stats = new SectionStats(),
                            Flags = new SectionFlags(),
                            AI = new SectionAIInfo(),
                            CreatedUtc = now,
                            ModifiedUtc = now
                        }
                    }
                }
            }
        };
    }

    private async Task OnEditorReady(IJSObjectReference editor)
    {
        _editorInstance = editor;
        await EnsureCommandsModuleAsync();
    }

    private Task OnBoldRequested() => InvokeCommandAsync("toggleBold");

    private Task OnItalicRequested() => InvokeCommandAsync("toggleItalic");

    private Task OnStrikeRequested() => InvokeCommandAsync("toggleStrike");

    private Task OnCodeRequested() => InvokeCommandAsync("toggleCode");

    private Task OnParagraphRequested() => InvokeCommandAsync("setParagraph");

    private Task OnHeadingRequested(int level) => InvokeCommandAsync("toggleHeading", level);

    private Task OnBlockquoteRequested() => InvokeCommandAsync("toggleBlockquote");

    private Task OnHorizontalRuleRequested() => InvokeCommandAsync("insertHorizontalRule");

    private Task OnBulletListRequested() => InvokeCommandAsync("toggleBulletList");

    private Task OnOrderedListRequested() => InvokeCommandAsync("toggleOrderedList");

    private async Task EnsureCommandsModuleAsync()
    {
        if (_commandsModule is null)
        {
            _commandsModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                "import",
                "/js/tiptap-commands.js");
        }
    }

    private async Task InvokeCommandAsync(string command, params object?[] extraArgs)
    {
        if (_editorInstance is null)
        {
            return;
        }

        await EnsureCommandsModuleAsync();
        if (_commandsModule is null)
        {
            return;
        }

        object?[] args = new object?[1 + extraArgs.Length];
        args[0] = _editorInstance;
        for (int i = 0; i < extraArgs.Length; i++)
        {
            args[i + 1] = extraArgs[i];
        }

        await _commandsModule.InvokeVoidAsync(command, args);

        if (!string.Equals(command, "focusEditor", StringComparison.Ordinal))
        {
            await _commandsModule.InvokeVoidAsync("focusEditor", _editorInstance);
        }
    }

    private async Task OnSave()
    {
        try
        {
            Document normalized = NormalizeDocumentForSave(_state.Document);
            DocumentStorage payload = new(normalized);
            string json = JsonSerializer.Serialize(payload);
            await JSRuntime.InvokeVoidAsync("localStorage.setItem", StorageKey, json);

            string documentKey = StoragePrefix + normalized.DocumentId;
            await JSRuntime.InvokeVoidAsync("localStorage.setItem", documentKey, json);
            await UpdateDocumentIndexAsync(normalized);
            _state.ReplaceDocument(normalized, notify: false);
            RefreshFromDocument(normalized);
            _lastSavedUtc = normalized.Metadata.ModifiedUtc;
            _isDirty = false;
            await InvokeAsync(StateHasChanged);
        }
        catch (JSException)
        {
        }
    }

    private async Task LoadDocumentAsync()
    {
        string? json = null;
        try
        {
            json = await JSRuntime.InvokeAsync<string>("localStorage.getItem", StorageKey);
        }
        catch (JSException)
        {
            return;
        }

        if (string.IsNullOrWhiteSpace(json))
        {
            if (_savedDocuments.Count == 0)
            {
                return;
            }

            DocumentIndexEntry latest = _savedDocuments[0];
            await LoadDocumentByIdAsync(latest.DocumentId.ToString());
            return;
        }

        DocumentStorage? payload = JsonSerializer.Deserialize<DocumentStorage>(json);
        if (payload?.Document is null)
        {
            return;
        }

        InitializeState(NormalizeDocumentForLoad(payload.Document));
        await SyncEditorAsync();
    }

    private async Task LoadDocumentByIdAsync(string documentId)
    {
        string key = StoragePrefix + documentId;
        string? json = null;
        try
        {
            json = await JSRuntime.InvokeAsync<string>("localStorage.getItem", key);
        }
        catch (JSException)
        {
            return;
        }

        if (string.IsNullOrWhiteSpace(json))
        {
            return;
        }

        DocumentStorage? payload = JsonSerializer.Deserialize<DocumentStorage>(json);
        if (payload?.Document is null)
        {
            return;
        }

        InitializeState(NormalizeDocumentForLoad(payload.Document));
        await SyncEditorAsync();
    }

    private async Task LoadDocumentIndexAsync()
    {
        _savedDocuments.Clear();

        string? json = null;
        try
        {
            json = await JSRuntime.InvokeAsync<string>("localStorage.getItem", StorageIndexKey);
        }
        catch (JSException)
        {
            return;
        }

        if (string.IsNullOrWhiteSpace(json))
        {
            return;
        }

        List<DocumentIndexEntry>? entries = JsonSerializer.Deserialize<List<DocumentIndexEntry>>(json);
        if (entries is null)
        {
            return;
        }

        entries.Sort((a, b) => b.LastModifiedUtc.CompareTo(a.LastModifiedUtc));
        _savedDocuments.AddRange(entries);
    }

    private async Task UpdateDocumentIndexAsync(Document document)
    {
        string title = string.IsNullOrWhiteSpace(document.Metadata.Title)
            ? "Untitled"
            : document.Metadata.Title;

        DocumentIndexEntry entry = new(document.DocumentId, title, document.Metadata.ModifiedUtc);

        int index = _savedDocuments.FindIndex(item => item.DocumentId == entry.DocumentId);
        if (index >= 0)
        {
            _savedDocuments[index] = entry;
        }
        else
        {
            _savedDocuments.Add(entry);
        }

        _savedDocuments.Sort((a, b) => b.LastModifiedUtc.CompareTo(a.LastModifiedUtc));
        string json = JsonSerializer.Serialize(_savedDocuments);

        try
        {
            await JSRuntime.InvokeVoidAsync("localStorage.setItem", StorageIndexKey, json);
        }
        catch (JSException)
        {
        }
    }

    private Document NormalizeDocumentForSave(Document document)
    {
        Document normalized = NormalizeDocumentForLoad(document);
        DocumentMetadata updatedMetadata = normalized.Metadata with { ModifiedUtc = DateTime.UtcNow };
        return normalized with { Metadata = updatedMetadata };
    }

    private Document NormalizeDocumentForLoad(Document document)
    {
        string? title = document.Metadata.Title;
        if (string.IsNullOrWhiteSpace(title))
        {
            title = DeriveTitleFromDocument(document);
        }

        DocumentMetadata updatedMetadata = document.Metadata with
        {
            Title = title ?? document.Metadata.Title
        };

        List<Chapter> chapters = new();
        for (int chapterIndex = 0; chapterIndex < document.Chapters.Count; chapterIndex++)
        {
            Chapter chapter = document.Chapters[chapterIndex];
            List<Section> sections = new();
            for (int sectionIndex = 0; sectionIndex < chapter.Sections.Count; sectionIndex++)
            {
                Section section = chapter.Sections[sectionIndex];
                SectionStats stats = new()
                {
                    WordCount = CountWords(section.Content.Value),
                    CharacterCount = CountCharacters(section.Content.Value)
                };

                sections.Add(section with { Stats = stats });
            }

            chapters.Add(chapter with { Sections = sections });
        }

        return document with
        {
            Metadata = updatedMetadata,
            Chapters = chapters
        };
    }

    private static string? DeriveTitleFromDocument(Document document)
    {
        Regex headingRegex = new("<h[1-6][^>]*>(.*?)</h[1-6]>", RegexOptions.IgnoreCase | RegexOptions.Singleline);
        for (int chapterIndex = 0; chapterIndex < document.Chapters.Count; chapterIndex++)
        {
            Chapter chapter = document.Chapters[chapterIndex];
            for (int sectionIndex = 0; sectionIndex < chapter.Sections.Count; sectionIndex++)
            {
                Section section = chapter.Sections[sectionIndex];
                string html = section.Content.Value ?? string.Empty;
                Match match = headingRegex.Match(html);
                if (!match.Success)
                {
                    continue;
                }

                string plain = ExtractPlainText(match.Groups[1].Value);
                if (string.IsNullOrWhiteSpace(plain))
                {
                    continue;
                }

                plain = Regex.Replace(plain, @"\s+", " ").Trim();
                if (plain.Length > 60)
                {
                    plain = plain.Substring(0, 60).Trim();
                }

                return plain;
            }
        }

        return null;
    }

    private void InitializeState(Document document)
    {
        _state.OnChanged -= _onChangedHandler;
        _state = new DocumentState(document);
        _commandProcessor = new CommandProcessor(_state);
        _state.OnChanged += _onChangedHandler;

        if (document.Chapters.Count > 0 && document.Chapters[0].Sections.Count > 0)
        {
            _activeSectionId = document.Chapters[0].Sections[0].SectionId;
        }

        RefreshFromDocument(_state.Document);
        _lastSavedUtc = _state.Document.Metadata.ModifiedUtc;
        _isDirty = false;
    }

    private async Task SyncEditorAsync()
    {
        if (_editorRef is null)
        {
            return;
        }

        _suppressEditorEvent = true;
        try
        {
            await _editorRef.SetContentAsync(_activeSectionContent);
        }
        finally
        {
            _suppressEditorEvent = false;
        }
    }

    private string GetDirtyLabel() => _isDirty ? "Unsaved changes" : "All changes saved";

    private string GetDirtyClass() => _isDirty ? "dirty-indicator" : "clean-indicator";

    private string GetLastSavedLabel()
    {
        if (_lastSavedUtc == default)
        {
            return "Not saved yet";
        }

        TimeSpan delta = DateTime.UtcNow - _lastSavedUtc;
        if (delta < TimeSpan.FromMinutes(1))
        {
            return "Last saved just now";
        }

        if (delta < TimeSpan.FromHours(1))
        {
            int minutes = Math.Max(1, (int)Math.Round(delta.TotalMinutes));
            return $"Last saved {minutes} min ago";
        }

        if (delta < TimeSpan.FromDays(1))
        {
            int hours = Math.Max(1, (int)Math.Round(delta.TotalHours));
            return $"Last saved {hours} hr ago";
        }

        int days = Math.Max(1, (int)Math.Round(delta.TotalDays));
        return $"Last saved {days} day{(days == 1 ? string.Empty : "s")} ago";
    }

    public void Dispose()
    {
        _state.OnChanged -= _onChangedHandler;
    }

    public async ValueTask DisposeAsync()
    {
        if (_disposed)
        {
            return;
        }

        _disposed = true;

        if (_commandsModule is not null)
        {
            try
            {
                await _commandsModule.DisposeAsync();
            }
            catch (ObjectDisposedException)
            {
            }
            catch (JSDisconnectedException)
            {
            }
            finally
            {
                _commandsModule = null;
            }
        }
    }

    private sealed record DocumentStorage(Document Document);

    private sealed record DocumentIndexEntry(Guid DocumentId, string Title, DateTime LastModifiedUtc);
}
